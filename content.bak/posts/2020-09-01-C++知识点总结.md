---
title: C++知识点总结
date: 2020-09-01 21:33:19
<<<<<<< HEAD
categories: 
- Notes
tags:
- C++
- ch
=======
categories:
- Notes
- Ch
tags:
- C++
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
---

### 1. 虚函数和纯虚函数

<<<<<<< HEAD
---

1. 虚函数：为了动态绑定，允许被子类重新定义的成员函数， virtual returnType func(parameter); 
2. 纯虚函数：为了派生接口，virtual returnType func(parameter) = 0;
3. 基类需要虚析构函数的原因：防止内存泄漏，假如没有虚析构函数，释放一个由基类指向派生类的对象是，不触发动态绑定，则只会调用基类析构函数，而不会调用派生类的，从而导致派生类内存空间的不到释放。 
=======
1. 虚函数：为了动态绑定，允许被子类重新定义的成员函数， virtual returnType func(parameter);
2. 纯虚函数：为了派生接口，virtual returnType func(parameter) = 0;
3. 基类需要虚析构函数的原因：防止内存泄漏，假如没有虚析构函数，释放一个由基类指向派生类的对象是，不触发动态绑定，则只会调用基类析构函数，而不会调用派生类的，从而导致派生类内存空间的不到释放。
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59

<!--more-->

---

### 2. static和const关键字

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
static：存储在静态存储区，未初始化时自动初始化为0：

1. 局部变量：
   1. 变为静态局部变量；
   2. 作用域仍为局部作用域；
   3. 离开作用域仍驻留在内存中，但不可访问；
2. 全局变量：
   1. 变为全局静态变量；
   2. 在声明的文件之外不可见；
3. 成员变量：
   1. 变为类的全局变量，被类的对象共享，包括派生类的对象；
   2. 必须在类外进行初始化，如int base::var = 10;，但可以用const修饰static数据成员，从而在类内初始化；
4. 成员函数：
   1. 使得成员函数为所有对象共享，不含this指针；
   2. 可以独立访问，不需要创建实例，如base::func(3, 5);
   3. 不可直接引用类的非静态成员，但是可以引用静态成员；
   4. 不可同时用const和static修饰成员函数（const含this指针，static不含，冲突）；

const：

1. 表明变量不可修改；
2. 限定成员函数不可修改任何数据成员；
3. const与指针：
   1. const char *p：指向的内容不能改变；
   2. char * const p：将p声明为常指针，地址不能变，但是内容可变。

---

### 3. C++的内存分区

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放；
2. 堆区（heap）：用户通过malloc/new手动申请释放，分配类似链表；
3. 全局/静态区：存放全局变量、静态变量；
4. 字符串常量区：字符串常量；
5. 代码区：程序的二进制代码。

---

### 4. STL容器

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
底层数据结构：

1. vector：数组；
2. map、multimap：红黑树；
3. unordered_map、unordered_nultimap：哈希表。

---

### 5. 内存泄漏

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 一般为堆内存泄漏，即程序在运行中动态申请的内存空间不使用后，未及时释放；
2. 解决：
   1. 良好编程习惯；
   2. 重载new和delete，以链表形式自动管理分配的内存；
   3. 使用智能指针。

---

### 6. 32位、64位系统中，常用内置数据类型所占字节数

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 32位：
   1. char：1字节；
   2. 指针变量：4字节；
   3. short int：2字节；
   4. int：4字节；
   5. unsigned int：4字节；
   6. float：4字节；
   7. double：8字节；
   8. long：4字节；
   9. unsigned long：4字节；
   10. long long：8字节；
2. 64位：
   1. char：1字节；
   2. 指针变量：8字节；
   3. short int：2字节；
   4. int：4字节；
   5. unsigned int：4字节；
   6. float：4字节；
   7. double：8字节；
   8. long：8字节；
   9. unsigned long：8字节；
   10. long long：8字节。

---

### 7. inline、volatile关键字

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. inline：解决频繁调用小函数大量消耗栈空间的问题；
2. volatile：表明类型变量可被更改，不再优化，需要从如内存中重新读取。

---

### 8. 深拷贝与浅拷贝

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
拷贝函数使用场景：

1. 一个对象以值的方式传入函数体；
2. 一个对象以值的方式从函数返回；
3. 一个对象需通过另一个对象进行初始化；

区别：

1. 浅拷贝：只是增加一个指针指向已存在的内存地址；
2. 深拷贝：增加一个指针，并且申请一个新的内存用于存放复制的对象。

---

### 9. 派生类构造/析构函数调用顺序

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 构造函数：先基后派；
2. 析构函数：先派后基。

---

### 10. 数据成员初始化顺序

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
顺序：

1. 基类的静态变量或全局变量；
2. 派生类的静态变量或全局变量；
3. 基类的成员变量；
4. 派生类的成员变量。

---

### 11. static_cast, dynamic_cast, const_cast, reinpreter_cast区别

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
static_cast与dynamic_cast：

1. 发生时间不同，一个是static编译时，一个是runtime运行时；
2. static_cast为强制类型转换，不提供运行时的检查；
3. dynamic_cast用于转换指针和引用，不可用于转换对象，主要用于类层次间的上行和下行转换：
   1. 上行转换：B继承自A，由B转换为A；
   2. 下行转换：B继承自A，A转换为B；
4. 上行转换时，static_cast和dynamic_cast效果相同，下行转换时，dynamic_cast具有类型检查，更安全。

---

### 12. 定义一个空类 编译器会做什么

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 当用到相关函数时，编译器会去自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值操作符、默认析构函数；
2. 所有自动生成的函数都是inline和public的。

---

### 13. 哪些函数不能成为虚函数

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 构造函数：假如子类继承基类构造函数，则子类对象将使用基类构造函数构造，而基类的构造函数并不知道自类的成员，不符合语义，且，多态是通过基类指针指向子类对象实现多态的，在对象构造之前，并没有对象产生，因此无法使用多态特性，是矛盾的；
2. 内联成员函数：内联函数在编译时展开，而虚函数是在运行时绑定的，两者相违背；
3. 静态成员函数：在编译时确定，无法动态绑定，不支持多态。

---

### 14. 内联函数与宏定义的区别

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 宏定义在于处理时把所有宏名用宏体替换，内联函数在编译时进行代码插入、展开、省去调用的开销；
2. 宏定义没有类型检查，内联函数满足函数的性质，如有返回值、参数列表等。

---

### 15. 左值引用和右值引用

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 左值引用要求右边的值必须能够取地址，如果不能取地址，可以使用常引用；

   1. 例：`const int &var = 10;`等价于

      1. ```c++
         const int temp = 10;
         const int &var = temp;
         ```

   2. 但常引用修饰后，不可以通过引用进行修改，只能进行读取；

2. 右值引用用来绑定到右值；

   1. 左值：可以取地址的，有名字的，非临时的值；
   2. 右值：不能取地址的，没有名字的，临时的值；
   3. 定义格式`类型 && 引用名 = 右值表达式;`
   4. 例：`int &&var = 10;`

---

### 16. substr用法

<<<<<<< HEAD
---

=======
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
1. 目的：构建一个string；

2. 用法：s.substr(pos, n)：

   1. ```c++
      string s("testString");
      string newStr = s.substr(0, 6);
      ```

<<<<<<< HEAD
3. 注意：返回一个从pos开始，包含pos的n个字符，pos默认值为0，n默认值为s.size()-pos。
=======
3. 注意：返回一个从pos开始，包含pos的n个字符，pos默认值为0，n默认值为s.size()-pos。
>>>>>>> 38ebd639019f105c786e6269d9bf8a3491ecdd59
