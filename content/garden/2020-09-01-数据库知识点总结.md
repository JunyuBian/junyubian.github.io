---
title: 数据库知识点总结
date: 2020-09-01 17:22:16
categories: 
- Notes
tags:
- 数据库
- ch
---

### 1. 数据库范式

---

第一范式：列不可分；

第二范式：有主键，保证完全依赖于主键；

第三范式：无传递依赖。    

---

### 2. 索引

---

索引：对数据库表中一个或多个列的值进行排序的数据结构，从而达到快速查询、更新数据库表数据的目的；

实现：通常使用B树或B+树，如用B树可以实现O(logn)的时间复杂度检索：

1. B树特点（m叉树）：
   1. 树中每个节点最多有m个子节点；
   2. 所有叶子节点都在同一层；
2. B+树特点（InnoDB的索引实现）：
   1. 所有叶子节点中包含了所有关键码信息，及指向关键码记录的指针；
   2. 叶子节点本身根据关键码大小自小而大顺序链接；
   3. 含有两个指针，一个指向根节点，一个指向关键字最小的叶子节点；
3. B+树更适合文件和数据库索引的原因：
   1. B+树内部节点相对B树更小，磁盘读写代价更低；
   2. 每次查找都需要从根节点到叶子节点，查询效率更稳定；

索引的优点：

1. 加快数据检索速度；
2. 加快表与表之间的连接；
3. 减少分组和排序语句的时间；
4. 通过创建唯一性索引，保证数据库中每一行数据的唯一性；

设置了索引但是无法使用的情况：

1. 模糊查询，以“%”开头的Like语句；
2. OR语句前后没有同时使用索引；
3. 数据类型出现隐式转化，如varchar不加单引号自动转为int；
4. 对于多列索引，必须满足最左匹配原则：
   1. 如对于索引(a, b, c)，生效情况为a、(a, b)、(a, b, c)；
   2. 因为针对联合索引构建的B+树优先保证最左元素有序；

什么字段适合创建索引：

1. 经常作为查询选择的字段；
2. 经常作为表连接的字段；
3. 经常出现在order by、group by、distinct后面的字段；

创建索引时需要注意：

1. 非空字段：需要使用0或特殊值代替NULL，否则会使索引运算更加复杂；
2. 索引字段越小越好：数据库存储以页为单位，一页存储的数据越多，一次IO获取数据的效率越高；

索引缺点：

1. 时间：创建、维护索引需要耗费时间，对表中数据进行增加、删除、修改时，索引也要动态修改，降低了数据的维护速度；
2. 空间：索引需要额外的存储空间；

索引的分类：

1. 普通索引和唯一性索引：索引列值的唯一性；
2. 单个索引和复合索引：索引列包含的列数；
3. 聚簇索引和非聚簇索引：
   1. 聚簇索引：按照每张表的主键构建一个B+树，InnoDB中表数据文件本身就是按照B+树组织的索引结构；
   2. 非聚簇索引：按照value进行检索，最后获得想要数据的主键，再通过主索引进行检索；

唯一索引与主键索引：

1. 主键索引：为主键创建的唯一索引；
2. 唯一索引：索引列的值必须唯一，但允许有空值。

---

### 3. 数据库事务

---

事务的特性：

1. 原子性（Atomicity）：事务所包含的一系列语句，要么全部成功执行，要么全部回滚；
2. 一致性（Consistency）：事务的执行结果必须使数据库从一个一致性状态到领一个一致性状态；
3. 隔离性（Isolation）：并发执行的并发之间不能相互影响；
4. 持久性（Durability）：事务一旦提交，对数库中的数据改变是永久性的；

事务并发带来的问题：

1. 脏读：一个事务读取了另一个事务未提交的数据；
2. 不可重复读：同样条件下，两次读取结果不同，即，被读取的数据可以被其他事务修改；
3. 幻读：同样条件下，两次读出的记录数不一样，即，被读取的数据可以被其他事务新增或删除；

隔离级别：

1. 读未提交（Read Uncommitted）：允许一个事务读取另一个事务还没提交的数据，可能会提高性能，但是会导致脏读；
2. 读已提交（Read Committed）：只允许读到其他事物已经提交的数据，不能避免不可重复读；
3. 可重复读（Repeatable Read）：一个事务开启后，其他事务对于数据库的修改在本事务中不可见，直到本事务提交或回滚，但是，其他事物的删除新增可见，不能避免幻读的问题；
4. 串行化（Serializable）：只允许事务串行执行；
5. MySQL默认隔离级别是Repeatable Read。

---

### 4. MySQL的优化

---

SQL语句及索引的优化：

1. SQL语句的优化：
   1. 通过慢查询日志，找出IO大的SQL、未命中索引的SQL，从而进行优化；
   2. 通过explain了解MySQL对于语句的处理，若扩展列extra出现Using filesort和Using temporay表示SQL需要优化；
   3. 其他tips：
      1. 优化insert语句：一次插入多值；
      2. 避免在where子句中使用!=或<>，以及避免在where子句中对字段进行null值判断，否则引擎会放弃使用索引而进行全表扫描；
      3. 优化嵌套查询：使用join代替子查询；
      4. 考虑用exists代替in；
2. 索引优化：
   1. 在经常做查询选择的字段、表连接的字段、经常出现在order by/group by/distincy后的字段中建立索引；
   2. 避免索引失效；
3. 表结构的优化：
   1. 选择合适的数据类型：
      1. 尽量选择较小的数据类型；
      2. 尽量使用简单的数据类型，int比varchar容易处理；
      3. 尽可能使用非空定义字段；
      4. 尽量避免使用text类型，非用不可需考虑分表；
   2. 表的范式优化；
   3. 垂直拆分和水平拆分：
      1. 垂直拆分：将表按照业务分类，分不到不同的数据库上，将数据压力分担到不同库上面；
      2. 水平拆分：将同一张表中的数据拆分到不同数据库中进行存储，或者把一张表拆分成多张小表；

---

### 5. drop、delete和truncate区别

---

1. delete：
   1. 用来删除表的全部或一部分数据行；
   2. 需要提交或回滚来执行或撤销删除操作；
2. truncate：
   1. 删除表中所有数据；
   2. 不可回滚；
   3. 比delete更快，占用空间更小；
3. drop：
   1. 删除表、所有数据行、索引等；
   2. 不可回滚；
4. 总结：不需要一张表的时候，用drop；想删除部分数据行时，用delete；保留表结构但删除所有数据时，用truncate。

---

### 6. 悲观锁与乐观锁

---

1. 悲观锁：
   1. 先获取锁在进行业务操作；
   2. 通过select ... for update来实现，在当前事务结束时自动释放；
   3. MySQL中使用2.时所有扫描过的行都会上锁，需要确认使用了索引而不是全表扫描；
2. 乐观锁：
   1. 先进行业务操作，最后更新时检查是否被更新，若未被更新，则更新成功，否则失败重试；
   2. 依靠逻辑实现；
   3. 在业务操作前获取需要锁的数据的版本号，更新时进行对比；
3. 应用场景：
   1. 读多写少适合乐观锁；
   2. 读少写多适合悲观锁。

---

### 7. MySQL中MyISAM和InnoDB的差异

---

1. 存储结构：
   1. MyISAM存储为：.frm文件存储表定义、.MYD数据文件、.MYI索引文件；
   2. InnoDB都保存在同一个数据文件中；
2. 存储空间：
   1. MyISAM可被压缩，占据的存储空间较小；
   2. InnoDB需要更多内存和存储，会在主内存中建立专用的缓冲池，用于高速缓冲数据和索引；
3. 事务支持：
   1. MyISAM每次查询具有原子性，执行速度比InnoDB更快，但是不支持事务；
   2. InnoDB支持事务、外键，具有事务提交、回滚等能力；
4. 表锁差异：
   1. MyISAM只支持表级锁，CRUD时会自动给表加锁；
   2. InnoDB支持行级锁，在where主键时生效，非主键锁全表。