---
title: 知识点整理
date: 2020-04-15
draft: false
garden_tags: ["ch", "notes"]
summary: " "
status: "growing"
---

# 1. C++的内存管理分哪些区，分别有什么作用

C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。

**堆区**：程序员分配释放，使用new分配内存块，使用delete归还内存空间。

**栈区**：编译器自动分配释放，用于存放局部变量、函数参数等。

**自由存储区**：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。

**全局区/静态区**：全局变量和静态变量分配在同一块内存中。

**常量存储区**：存放不可修改的常量值。

# 2. C++源文本到可执行文件需要经历哪些阶段

**预处理**：将源代码和相关头文件处理成一个.i文件。

**编译**：将预处理的文件进行词法分析、语义分析，优化后产生相应的汇编代码。

**汇编**：将汇编语言代码翻译成目标机器码。

**链接**：把每个机器码文件按照要求连接起来，解决代码间的相互依赖问题。

# 3. 析构函数为什么必须是虚函数

为了保证整个派生类的对象完全被释放。

当析构函数不为虚函数时，在删除基类指针时，只会调用基类析构函数，而不调用派生类的析构函数，这样会导致基类指针指向的派生类对象析构不完全。

当析构函数为虚函数时，在删除基类指针时，会调用该指针指向派生类的析构函数，同时派生类的析构函数自动调用基类析构函数，保证对象被完全释放。

# 4. 虚函数和纯虚函数有什么区别

**虚函数**：在基类中存在定义，可以直接使用，也可以被派生类重写后使用。

**纯虚函数**：在基类中不存在定义，只有声明，必须在子类中定义后才能使用。

# 5. 虚函数的实现机制

编译器自动为存在虚函数的类生成一个虚函数表，当声明该类的对象时，放入一个隐式指针变量，指向虚函数表。

在调用方法时，系统根据不同对象的指针，寻找到对应的虚函数表，进而找到所需的函数地址进行调用。

# 6.野指针怎么出现的

指针变量未初始化。

指针释放后未置空。

返回指向栈内存的指针。

# 7. 类和结构体有什么区别

class中默认成员访问权限为private，而struct中为public。

class可以用于表示模板类型，sruct不行。

class是引用类型，struct是值类型。

class多用来存储数据量大、逻辑复杂的对象，struct多用来存储轻量级对象。

class多用于表现抽象和多级别的对象层次。

# 8. 什么情况会导致内存泄漏

程序循环new创建出来的对象没有及时delete掉。

delete掉一个void*类型的指针，导致没有调用到对象的析构函数。

new创建了一组对象，回收时未调用delete[]，而调用了delete，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存。

# 9. 五种IO模型

**阻塞IO**：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，处理完毕后返回进程。

**非阻塞IO**：进程发起IO系统调用后，如果内核缓冲区没有数据，返回给进程一个错误，而不会阻塞进程，如果缓冲区有数据，则将数据返回给进程。【发起IO后，内核便开始处理，一直有返回值，但是直到内核处理完才有数据。】

**IO复用**：多个进程的IO注册到一个复用器（select）上，select监听所有进来的IO。【同时负责很多水龙头，哪个水龙头要来水了，就打开哪一个。】

**信号驱动IO**：进程发起IO系统调用后，向内核注册信号处理函数，然后进程返回不阻塞，当内核数据就绪则通知进程发起IO调用读取数据。【首先用信号通知内核空间，等到数据就绪再发起IO。】

**异步IO**：进程发起IO系统调用后，进程返回不阻塞，等内核将IO处理完，通知进程数据结果。

# 10. TCP如何保证传输的可靠性

**校验和**：接收方和发送方均进行校验和的计算，并进行对比。

**序列号**：TCP传输时将每个字节的数据都进行编号。

**确认应答**：TCP传输过程中，每次接收方收到数据后，均对传输方进行确认应答（ACK）。

**超时重传**：发送方在发送完数据后进行等待，一段时间后没有收到ACK，则对刚才的数据进行重新发送。

**连接管理**：三次握手与四次挥手。

**流量控制**：在回复ACK时，接收端介绍自己接受数据的缓冲区剩余大小。

**拥塞控制**：慢开始、拥塞避免等操作。

# 11. TCP快速重传的实现

举例：发送方发出1、2、3、4、5五份数据，1送到了，则回复ACK2，但是2没送到，3送到了，于是继续回复ACK2，后面4和5都送到了，继续回复ACK2，直到发送端收到三次ACK2，则重新发送2，然后接收端收到2，因为3、4、5都已经收到，所以回复ACK6。

# 12. 两个有序链表合并成一个(leetcode 21)

```c++
struct ListNode {
   int val;
   ListNode *next;
   ListNode(int x) : val(x), next(NULL) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
   if(l1 == NULL){
      return l2;
   }
   if (l2 == NULL){
      return l1;
   }
   if (l1->val < l2->val){
      l1->next = mergeTwoLists(l1->next, l2);
      return l1;
   }
   else {
      l2->next = mergeTwoLists(l1, l2->next);
      return l2;
   }
}
```

# 13. GET和POST的区别

GET所发送的数据是URL的一部分，POST数据不会显示在URL中。

GET和POST方法没有本质区别，只是报文格式不同，两者都使用HTTP，都是不安全的，想要安全传输需要使用HTTPS。

# 14. HTTPS的实现原理

HTTPS原理：在传输层（TCP）和应用层（HTTP）之间加了一层SSL/TLS。

具体加密过程：1. 服务器端发送公钥证书；2. 客户端检验证书是否有效，是，则生成一个随机密钥，并用服务端的公钥进行加密后发送；3. 服务器端用自己私钥加密，取出客户端的随机密钥，将需要发送的内容用该密钥加密并发送。

# 15. Linux查看最近的日志用什么指令

**tail**：

> tail -f test.log

**head**：

> cat test.log | tail -n +3000 | head -n 1000

**cat**：

> cat filename

**tac**：把cat的内容反写过来

> tac filename

**echo**：

> echo "the echo command test!"

# 16. hash冲突解决

**开放地址法**：再散列函数：

> Hi = (H(key) + di) % m, i = 1, 2, ..., n

不同di值对应不同散列方法。

**再哈希法**：同时构造多个不同的哈希函数，某一个发生冲突时计算下一个，直到冲突不再产生。

**链地址法**：将所有哈希地址为i的元素构成一个单链表。

**建立公共溢出区**：将哈希表分为基本表和溢出表，和基本表发生冲突的元素填入溢出表。

# 17. 快排的时间复杂度和空间复杂度

平均情况下快速排序的时间复杂度是O(nlgn)，最坏情况是n的平方，可通过随机算法避免最坏情况，或者可先求序列的中值，然后选取中值作为主元素。

由于递归调用，快排的空间复杂度是O(lgn)。

# 18. 堆排序的时间复杂度和空间复杂度

第一次建堆时间复杂度：O(n)。

更改元素时建堆时间复杂度：O(nlgn)。

堆排序平均时间复杂度：O(nlgn)。

空间复杂度：O(1)。

# 19. B树和B+树的定义

B树中每个节点的关键字都有data域。

B+树除了叶子节点，其他节点只有索引。

# 20. C++ vector里size和capacity的区别

size是当前vector容器的真实占用大小。

capacity是当前允许的最大元素数。

# 21. 计算机网络分层模型

> **7层** (osi国际标准组织定制)：

**应用层**：为程序提供网络服务。

**表示层**：数据格式化，加密、解密。

**会话层**：建立、维护、管理会话链接。

**传输层**：建立、维护、管理端到端链接。

**网络层**：IP寻址和路由选择。

**数据链路层**：控制网络层与物理层之间的通信。

**物理层**：比特流传输。

> **四层** (TCP/IP)：

**应用层**：ping、DNS、telnet

**传输层**：UDP、TCP

**网络层**：ICMP、IP

**数据链路层**：ARP、DataLink、RARP

# 22. HTTP请求包含哪几个部分

> **请求行**：

**请求方法**：HTTP最常见的请求方法为GET和POST。

**请求URL**：请求对应的URL地址。

**HTTP协议及版本**：协议名称及版本号。

> 请求头：

包含多个属性，格式为“属性名：属性值”，服务器根据请求头来获取客户端的信息。

> 请求体：

将一个页面表单中的组件值通过param1=value & param2=value2的键值对形式编码成一个格式化串，承载多个请求参数的数据。

# 23. TCP拥塞控制

主要为四个算法：

**慢开始**：在TCP链接刚建立时，一点一点地增大拥塞窗口cwnd，慢慢变为指数增长，试探网络的承受能力，直到cwnd大于等于ssthresh（slow start threshold）则进入**拥塞避免**。

**拥塞避免**：收到一个ACK，即每经过一个往返时间RTT，就把发送方的cwnd加1，使其按线性规律缓慢增长。

**乘法减小**【TCP Tahoe】：不论在慢开始阶段还是拥塞避免阶段，只要出现超时，即可能发生了阻塞，发生丢包，就把慢开始门限ssthresh的值减半，即设置为当前cwnd的一半，并开始执行**慢开始**算法。

**快速重传**【TCP Reno】：发生丢包时，把cwnd设置为当前的一半，ssthresh设置为缩小后的cwnd大小，进入**快速恢复**算法。

**快速恢复**【TCP Reno】：设置cwnd=cwnd+3*MSS（因为收到3个重复的ACK，所以加三个MSS），重传DACKs指定的数据包，如果再收到DACKs，则cwnd增加1，若收到新的ACK，表明重传包成功，退出快速恢复，将cwnd设置为ssthresh，进入**拥塞避免**算法。

# 24. 死锁与死锁的处理

> 形成死锁的四个必要条件：

**互斥**：在某段时间内某资源只由一个进程占用。

**持有并等待**：某进程已经持有一个或多个资源，但是还需请求其他资源，而它请求的资源不能立即获得，需要等待。

**不可抢占**：进程已经获取的资源在使用过程中不能被其他进程抢占，只能在使用完后，由该进程自己释放。

**环路等待**：形成进程和请求资源之间的环路。

> 死锁的预防：

**互斥**：不易预防

**占有并等待**：方法一：不持有并等待，如果一个进程一次请求获取不了所有资源，那么它不可占用任何资源，即释放掉它已经占有的资源；方法二：持有不等待，保证资源充足，只要请求资源，就分配给资源。

**不可抢占**：如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。

**环路等待**：对资源进行排序，每个进程按照固定的顺序访问资源。

> 死锁的避免：

**资源请求图算法**：利用资源分配图，引入需求边表示进程可能在将来某个时候申请资源，只有申请边变为分配边而不会导致资源分配图形成环时，才允许申请。

**银行家算法**：当新进程进入系统，系统对其所需资源的最大数量进行统计，若超过当前资源综合，则该进程必须等待直到其他进程释放资源。

# 25. 什么是关系型数据库

关系型数据库建立在关系型数据模型的基础上，借助于集合、代数等数学概念和方法来处理数据的数据库。

# 26. KV存储

举例：Redis、MongoDB

不经常更新的、重要的数据一般使用关系数据库存储。

数据结构简单、有分布式数据存储的需求使用KV数据库。

# 27. 非递归前中后序遍历二叉树

```c++
struct TreeNode {
  int val;
  TreeNode * left;
  TreeNode * right;
};

void PreOrder (TreeNode * root) {
  stack<TreeNode *>s;
  TreeNode * ptr = root;
  
  while (ptr != nullptr || !s.empty()) {
    if (ptr != nullptr) {
      cout << ptr->val << endl;
      s.push(ptr);
      ptr = ptr->left;
    }
    else {
      ptr = s.top();
      s.pop();
      ptr = ptr->right;
    }
  }
}

void InOrder (TreeNode * root) {
  stack<TreeNode *> s;
  TreeNode * ptr = root;
  
  while (ptr != nullptr || !s.empty()) {
    if (ptr != nullptr) {
      s.push(ptr);
      ptr = ptr->left;
    }
    else {
      ptr = s.top();
      cout << ptr->val << endl;
      s.pop();
      ptr = ptr->right;
    }
  }
}

void PostOrder (TreeNode * root) {
  stack<TreeNode *> s;
  TreeNode * ptr = root;
  TreeNode * TemNode = nullptr;
  
  while (ptr != nullptr || !s.empty()) {
    if (ptr != nullptr {
      s.push(ptr);
      ptr = ptr->left;
    }
    else {
      ptr = s.top();
      if (ptr->right != nullptr && ptr->right !- TemNode){
        ptr = ptr->right;
      }
      else {
        cout << ptr->val << endl;
        s.pop();
        TemNode = ptr;
        ptr = nullptr;
      }
    }   
  }
}
```

# 28. 如何实现一个栈

```c++
class QueueStack {
private:
  queue<int> first;
  queue<int> second;
  
public:
  bool empty() {
		if (first.empty() && second.empty()){
      return true;
    }
    else {
      return false;
    }
  }
  
  int top() {
    if (first.empty()){
      return second.front();
    }
    else {
      return first.front();
    }
  }
  
  void pop() {
    if (first.empty()) {
      second.pop();
    }
    else {
      first.pop();
    }
  }
  
  void push (int x){
    if (frist.empty()){
      first.push(x);
      while (!second.empty()) {
        first.push(second.front());
        second.pop();
      }
    }
    else {
      second.push(x);
      while(!first.empty()) {
        second.push(first.front());
        first.pop();
      }
    }
  }
}
```

# 29. HTTP状态码

> 1xx：收到请求，需要请求者继续操作。

**100**：继续。

**101**：切换协议。

> 2xx：操作被成功接收并处理。

**200**：请求成功。

**201**：已创建。

**202**：已接受。

**203**：非授权信息。请求成功。

**204**：无内容。

**205**：重置内容。

**206**：部分内容。

> 3xx：重定向，需要进一步操作以完成请求。

**300**：多种选择。

**301**：永久移动。

**302**：临时移动。

**303**：查看其他地址。

**304**：未修改。

**305**：使用代理。

**307**：临时重定向。

> 4xx：客户端错误，请求包含语法错误或无法完成请求。

**400**：Bad Request。

**401**：Unauthorized。

**403**：服务器理解客户端的请求，但是拒绝执行。

**404**：无法根据请求找到资源。

**405**：客户端请求中的方法被禁止。

**406**：Not Acceptable。

**407**：Proxy Authentication Required。

**408**：Request Timeout。

**409**：服务器处理请求时发生了冲突。

**410**：客户端请求的资源已经不存在。

**411**：Length Required。

**412**：Precondition Failed。

**413**：Request Entity Too Large。

**414**：Request URI Too Large。

**415**：Unsupported Media Type。

**416**：客户端请求的范围无效。

**417**：Expectation Failed。

> 5xx：服务器错误，服务器在处理请求的过程中发生了错误。

**500**：服务器内部错误，无法完成请求。

**501**：服务器不支持请求的功能。

**502**：Bad Gateway.

**503**：Service Unavailable.

**504**：Gateway Timeout.

**505**：HTTP version not supported.
