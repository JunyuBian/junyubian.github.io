<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ch on Junyu Bian</title>
    <link>https://junyubian.github.io/tags/ch/</link>
    <description>Recent content in ch on Junyu Bian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Apr 2021 15:19:00 +0000</lastBuildDate>
    <atom:link href="https://junyubian.github.io/tags/ch/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FD.io简介</title>
      <link>https://junyubian.github.io/posts/2021-04-26-fdio%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 26 Apr 2021 15:19:00 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2021-04-26-fdio%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;总结自&lt;a href=&#34;https://www.youtube.com/watch?v=rfat_guzoEI&#34;&gt;fd.io Youtube&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux知识点总结</title>
      <link>https://junyubian.github.io/posts/2020-09-28-linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 28 Sep 2020 22:43:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-28-linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;1-find命令&#34;&gt;1. find命令&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;查找指定文件名文件（不区分大小写）：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find -iname &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ProgramToFind.java&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对找到的文件执行某命令&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find -iname &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ProgramToOperate.java&amp;#34;&lt;/span&gt; -exec md5sum &lt;span style=&#34;color:#f92672&#34;&gt;{}&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;查找home目录下所有空文件&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find ~ -empty
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Recursion&#43;Backtrack</title>
      <link>https://junyubian.github.io/posts/2020-09-15-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-recursion&#43;backtrack/</link>
      <pubDate>Tue, 15 Sep 2020 22:12:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-15-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-recursion&#43;backtrack/</guid>
      <description>&lt;h3 id=&#34;题目17电话号码的字母组合httpsleetcode-cncomproblemsletter-combinations-of-a-phone-number&#34;&gt;题目17:&lt;a href=&#34;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&#34;&gt;电话号码的字母组合&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入：&amp;ldquo;23&amp;rdquo;
输出：[&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;].&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Graph</title>
      <link>https://junyubian.github.io/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-graph/</link>
      <pubDate>Sat, 12 Sep 2020 21:32:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-graph/</guid>
      <description>&lt;h3 id=&#34;题目133克隆图httpsleetcode-cncomproblemsclone-graph&#34;&gt;题目133:&lt;a href=&#34;https://leetcode-cn.com/problems/clone-graph/&#34;&gt;克隆图&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。&lt;/p&gt;
&lt;p&gt;图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。&lt;/p&gt;
&lt;p&gt;class Node {
public int val;
public List&lt;!-- raw HTML omitted --&gt; neighbors;
}&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Queue&#43;TopologicalSort</title>
      <link>https://junyubian.github.io/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-queue&#43;topologicalsort/</link>
      <pubDate>Sat, 12 Sep 2020 21:32:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-queue&#43;topologicalsort/</guid>
      <description>&lt;h3 id=&#34;题目621任务调度器httpsleetcode-cncomproblemstask-scheduler&#34;&gt;题目621:&lt;a href=&#34;https://leetcode-cn.com/problems/task-scheduler/&#34;&gt;任务调度器&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。&lt;/p&gt;
&lt;p&gt;然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-DP&#43;Greedy</title>
      <link>https://junyubian.github.io/posts/2020-09-11-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dp&#43;greedy/</link>
      <pubDate>Fri, 11 Sep 2020 11:52:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-11-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dp&#43;greedy/</guid>
      <description>&lt;h3 id=&#34;题目5最长回文子串httpsleetcode-cncomproblemslongest-palindromic-substring&#34;&gt;题目5:&lt;a href=&#34;https://leetcode-cn.com/problems/longest-palindromic-substring/&#34;&gt;最长回文子串&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: &amp;ldquo;babad&amp;rdquo;
输出: &amp;ldquo;bab&amp;rdquo;
注意: &amp;ldquo;aba&amp;rdquo; 也是一个有效答案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Heap&#43;Stack</title>
      <link>https://junyubian.github.io/posts/2020-09-09-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-heap&#43;stack/</link>
      <pubDate>Wed, 09 Sep 2020 12:32:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-09-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-heap&#43;stack/</guid>
      <description>&lt;h3 id=&#34;题目20有效的括号httpsleetcode-cncomproblemsvalid-parentheses&#34;&gt;题目20:&lt;a href=&#34;https://leetcode-cn.com/problems/valid-parentheses/&#34;&gt;有效的括号&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个只包括 &amp;lsquo;(&amp;rsquo;，&amp;rsquo;)&amp;rsquo;，&amp;rsquo;{&amp;rsquo;，&amp;rsquo;}&amp;rsquo;，&amp;rsquo;[&amp;rsquo;，&amp;rsquo;]&amp;rsquo; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;p&gt;左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-DFS&#43;BFS</title>
      <link>https://junyubian.github.io/posts/2020-09-08-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dfs&#43;bfs/</link>
      <pubDate>Tue, 08 Sep 2020 14:03:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-08-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dfs&#43;bfs/</guid>
      <description>&lt;h3 id=&#34;题目116填充每个节点的下一个右侧节点指针httpsleetcode-cncomproblemspopulating-next-right-pointers-in-each-node&#34;&gt;题目116:&lt;a href=&#34;https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/&#34;&gt;填充每个节点的下一个右侧节点指针&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;p&gt;struct Node {
int val;
Node *left;
Node *right;
Node *next;
}&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Tree&#43;BST</title>
      <link>https://junyubian.github.io/posts/2020-09-07-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-tree&#43;bst/</link>
      <pubDate>Mon, 07 Sep 2020 21:13:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-07-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-tree&#43;bst/</guid>
      <description>&lt;h3 id=&#34;题目94二叉树的中序遍历httpsleetcode-cncomproblemsbinary-tree-inorder-traversal&#34;&gt;题目94:&lt;a href=&#34;https://leetcode-cn.com/problems/binary-tree-inorder-traversal/&#34;&gt;二叉树的中序遍历&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回它的中序 遍历。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [1,null,2,3]
1
&lt;br&gt;
2
/
3&lt;/p&gt;
&lt;p&gt;输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Two Pointer&#43;Linked List</title>
      <link>https://junyubian.github.io/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-two-pointer&#43;linked-list/</link>
      <pubDate>Sun, 06 Sep 2020 23:33:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-two-pointer&#43;linked-list/</guid>
      <description>&lt;h3 id=&#34;题目3无重复字符的最长子串httpsleetcode-cncomproblemslongest-substring-without-repeating-characters&#34;&gt;题目3:&lt;a href=&#34;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&#34;&gt;无重复字符的最长子串&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode题目总结-Array</title>
      <link>https://junyubian.github.io/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-array/</link>
      <pubDate>Sun, 06 Sep 2020 21:09:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-array/</guid>
      <description>&lt;h3 id=&#34;题目31下一个排列httpsleetcode-cncomproblemsnext-permutation&#34;&gt;题目31:&lt;a href=&#34;https://leetcode-cn.com/problems/next-permutation&#34;&gt;下一个排列&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;
&lt;p&gt;必须原地修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;知识点总结</title>
      <link>https://junyubian.github.io/posts/2020-09-01-c&#43;&#43;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 01 Sep 2020 21:33:19 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-01-c&#43;&#43;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;1-虚函数和纯虚函数&#34;&gt;1. 虚函数和纯虚函数&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;虚函数：为了动态绑定，允许被子类重新定义的成员函数， virtual returnType func(parameter);&lt;/li&gt;
&lt;li&gt;纯虚函数：为了派生接口，virtual returnType func(parameter) = 0;&lt;/li&gt;
&lt;li&gt;基类需要虚析构函数的原因：防止内存泄漏，假如没有虚析构函数，释放一个由基类指向派生类的对象是，不触发动态绑定，则只会调用基类析构函数，而不会调用派生类的，从而导致派生类内存空间的不到释放。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>数据库知识点总结</title>
      <link>https://junyubian.github.io/posts/2020-09-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 01 Sep 2020 17:22:16 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-09-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;1-数据库范式&#34;&gt;1. 数据库范式&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;第一范式：列不可分；&lt;/p&gt;
&lt;p&gt;第二范式：有主键，保证完全依赖于主键；&lt;/p&gt;
&lt;p&gt;第三范式：无传递依赖。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统知识点总结</title>
      <link>https://junyubian.github.io/posts/2020-08-31-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 31 Aug 2020 19:32:21 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-08-31-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;1-进程和线程&#34;&gt;1. 进程和线程&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;进程：系统进行资源分配的基本单位；&lt;/li&gt;
&lt;li&gt;线程：CPU调度的基本单位：
&lt;ol&gt;
&lt;li&gt;共享进程的全部资源；&lt;/li&gt;
&lt;li&gt;独有程序计数器、寄存器和栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>计算机网络知识点总结</title>
      <link>https://junyubian.github.io/posts/2020-08-31-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 31 Aug 2020 16:40:10 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-08-31-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;1-https加密过程&#34;&gt;1. Https加密过程&lt;/h3&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;客户端发起握手请求；&lt;/li&gt;
&lt;li&gt;服务端返回已有的&lt;code&gt;证书公钥&lt;/code&gt;（服务端通过CA认证后，拥有&lt;code&gt;证书公钥&lt;/code&gt;和&lt;code&gt;证书私钥&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;客户端验证证书是否有效；&lt;/li&gt;
&lt;li&gt;若证书有效，则生成一个&lt;code&gt;随机数&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;证书公钥&lt;/code&gt;加密生成的随机数；&lt;/li&gt;
&lt;li&gt;将加密后的&lt;code&gt;密钥&lt;/code&gt;发送给服务端；&lt;/li&gt;
&lt;li&gt;服务端用&lt;code&gt;证书私钥&lt;/code&gt;解密密钥；&lt;/li&gt;
&lt;li&gt;服务端使用解密出的密钥加密要发送的内容并发送给客户端；&lt;/li&gt;
&lt;li&gt;客户端使用秘钥解密信息。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>知识点整理-6</title>
      <link>https://junyubian.github.io/posts/2020-07-23-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/</link>
      <pubDate>Thu, 23 Jul 2020 22:54:16 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-07-23-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-6/</guid>
      <description>&lt;h3 id=&#34;1-linux和端口号进程文件相关的命令&#34;&gt;1. Linux和端口号、进程、文件相关的命令&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;静态进程查看&lt;/strong&gt;: ps&lt;/p&gt;
&lt;p&gt;例：通过进程名查看进程号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ps ax | fgrep &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;进程名&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;网络查看&lt;/strong&gt;: netstat&lt;/p&gt;</description>
    </item>
    <item>
      <title>EMPLACE_BACK in C&#43;&#43;</title>
      <link>https://junyubian.github.io/posts/2020-05-16-emplace_back-in-c&#43;&#43;/</link>
      <pubDate>Sat, 16 May 2020 09:39:00 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-05-16-emplace_back-in-c&#43;&#43;/</guid>
      <description>&lt;p&gt;There are different type of containers in C++ STL. To add a new element into the back of a container, we normally use &lt;code&gt;push_back()&lt;/code&gt;. In this blog, we will look into a new way of performing push back - &lt;code&gt;emplace_back()&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;background-knowledge&#34;&gt;Background Knowledge&lt;/h1&gt;
&lt;p&gt;Rvalue References: with aim of increasing the efficiency of C++, rvalues are included. It doesn&amp;rsquo;t  need to copy the value, the rvalue reference is bound to the value itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>知识点整理-5</title>
      <link>https://junyubian.github.io/posts/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/</link>
      <pubDate>Mon, 20 Apr 2020 00:51:32 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-5/</guid>
      <description>&lt;h3 id=&#34;1-mysql查询10-20条的数据&#34;&gt;1. MySQL查询10-20条的数据&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;limit&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;</description>
    </item>
    <item>
      <title>知识点整理-4</title>
      <link>https://junyubian.github.io/posts/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/</link>
      <pubDate>Sun, 19 Apr 2020 21:07:23 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-19-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-4/</guid>
      <description>&lt;h3 id=&#34;1-黑盒测试和白盒测试&#34;&gt;1. 黑盒测试和白盒测试&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;黑盒测试：即功能性测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;等价类划分&lt;/strong&gt;：有效等价类即对于程序的规格来说是合理的、有意义的；无效等价类即对程序的规格来说是不合理的、每有意义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;边界值分析&lt;/strong&gt;：对各种边界情况设计测试用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因果图法&lt;/strong&gt;：根据输入的各种组合来设计测试用例，用于检查程序输入条件的各种组合情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>知识点整理-3</title>
      <link>https://junyubian.github.io/posts/2020-04-17-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/</link>
      <pubDate>Fri, 17 Apr 2020 14:22:01 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-17-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-3/</guid>
      <description>&lt;h3 id=&#34;1-计算机网络分层模型&#34;&gt;1. 计算机网络分层模型&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;7层&lt;/strong&gt; (osi国际标准组织定制)：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：为程序提供网络服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示层&lt;/strong&gt;：数据格式化，加密、解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话层&lt;/strong&gt;：建立、维护、管理会话链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;：建立、维护、管理端到端链接。&lt;/p&gt;</description>
    </item>
    <item>
      <title>知识点整理-2</title>
      <link>https://junyubian.github.io/posts/2020-04-16-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/</link>
      <pubDate>Thu, 16 Apr 2020 21:29:34 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-16-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-2/</guid>
      <description>&lt;h3 id=&#34;1-两个有序链表合并成一个leetcode-21&#34;&gt;1. 两个有序链表合并成一个(leetcode 21)&lt;/h3&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ListNode&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ListNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ListNode(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; val(x), next(NULL) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ListNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mergeTwoLists&lt;/span&gt;(ListNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; l1, ListNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; l2) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(l1 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l2 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l1&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; l2&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      l1&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mergeTwoLists(l1&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next, l2);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      l2&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mergeTwoLists(l1, l2&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; l2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;</description>
    </item>
    <item>
      <title>知识点整理-1</title>
      <link>https://junyubian.github.io/posts/2020-04-15-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/</link>
      <pubDate>Wed, 15 Apr 2020 22:27:57 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-15-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86-1/</guid>
      <description>&lt;h3 id=&#34;1-c的内存管理分哪些区分别有什么作用&#34;&gt;1. C++的内存管理分哪些区，分别有什么作用&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;C++的内存主要分为五大区：堆区、栈区、自由存储区、全局/静态存储区、常量存储区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆区&lt;/strong&gt;：程序员分配释放，使用new分配内存块，使用delete归还内存空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈区&lt;/strong&gt;：编译器自动分配释放，用于存放局部变量、函数参数等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由存储区&lt;/strong&gt;：程序员分配释放，使用malloc分配内存块，使用free归还内存空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局区/静态区&lt;/strong&gt;：全局变量和静态变量分配在同一块内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常量存储区&lt;/strong&gt;：存放不可修改的常量值。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
