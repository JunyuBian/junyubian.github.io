<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Junyu Bian</title>
    <link>https://junyubian.github.io/tags/algorithm/</link>
    <description>Recent content in Algorithm on Junyu Bian</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 Nov 2020 15:19:00 +0000</lastBuildDate>
    <atom:link href="https://junyubian.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Diff Array</title>
      <link>https://junyubian.github.io/posts/2020-11-08-diff-array/</link>
      <pubDate>Sun, 08 Nov 2020 15:19:00 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-11-08-diff-array/</guid>
      <description>&lt;p&gt;In this blog, we will talk about one trick can be used to solve problems to do with frequent addition and subtraction to a subsection of an array  - &lt;a href=&#34;https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/3.3-yi-xiang-bu-dao-xi-lie/cha-fen-ji-qiao&#34;&gt;Diff Array&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;functionality&#34;&gt;Functionality&lt;/h1&gt;&#xA;&lt;p&gt;Todo with frequent addition and subtraction to a subsection of an array.&lt;/p&gt;&#xA;&lt;p&gt;e.g. Given array &lt;code&gt;arr&lt;/code&gt;, add 1 for elements between  &lt;code&gt;arr[0]&lt;/code&gt; and &lt;code&gt;arr[3]&lt;/code&gt; inclusively, then, substract 3 for elements between  &lt;code&gt;arr[2]&lt;/code&gt; and &lt;code&gt;arr[5]&lt;/code&gt; inclusively, what will be the final &lt;code&gt;arr&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>SWAP Function</title>
      <link>https://junyubian.github.io/posts/2020-05-17-swap-function/</link>
      <pubDate>Sun, 17 May 2020 19:28:00 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-05-17-swap-function/</guid>
      <description>&lt;p&gt;In this blog, we will look into several ways of implementing swap in different ways.&lt;/p&gt;&#xA;&lt;h1 id=&#34;intermedia-variable&#34;&gt;Intermedia Variable&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; tem &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>EMPLACE_BACK in C&#43;&#43;</title>
      <link>https://junyubian.github.io/posts/2020-05-16-emplace_back-in-c&#43;&#43;/</link>
      <pubDate>Sat, 16 May 2020 09:39:00 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-05-16-emplace_back-in-c&#43;&#43;/</guid>
      <description>&lt;p&gt;There are different type of containers in C++ STL. To add a new element into the back of a container, we normally use &lt;code&gt;push_back()&lt;/code&gt;. In this blog, we will look into a new way of performing push back - &lt;code&gt;emplace_back()&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h1 id=&#34;background-knowledge&#34;&gt;Background Knowledge&lt;/h1&gt;&#xA;&lt;p&gt;Rvalue References: with aim of increasing the efficiency of C++, rvalues are included. It doesn&amp;rsquo;t  need to copy the value, the rvalue reference is bound to the value itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sorting Algorithms - Quick Sort</title>
      <link>https://junyubian.github.io/posts/2020-04-23-sorting-algorithms---quick-sort/</link>
      <pubDate>Thu, 23 Apr 2020 13:42:56 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-23-sorting-algorithms---quick-sort/</guid>
      <description>&lt;p&gt;In this series of blogs, we will talk about different sorting algorithms.&lt;/p&gt;&#xA;&lt;p&gt;All the algorithms in the table below will be covered.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Algorithm&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Average Case)&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Worst Case)&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Best Case)&lt;/th&gt;&#xA;&lt;th&gt;Merg&lt;/th&gt;&#xA;&lt;th&gt;Stability&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Bubble Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Quick Sort&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(logN)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Quick Sort (with Random Selection)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(logN)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Insertion Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Selection Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Heap Sort&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Merge Sort (with double divides)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Merge Sort (with multi divides)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Counting Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Bucket Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Radix Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h1&gt;&#xA;&lt;h2 id=&#34;how-to-do-it&#34;&gt;How to do it&amp;hellip;&lt;/h2&gt;&#xA;&lt;p&gt;Divide and conquer.&lt;/p&gt;&#xA;&lt;p&gt;In each division, seperate the data into two parts.&lt;/p&gt;&#xA;&lt;p&gt;All elements in the first part should be all less than the elements in the second part.&lt;/p&gt;&#xA;&lt;p&gt;Loop until the array is sorted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sorting Algorithms - Bubble Sort</title>
      <link>https://junyubian.github.io/posts/2020-04-22-sorting-algorithms---bubble-sort/</link>
      <pubDate>Wed, 22 Apr 2020 09:23:36 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-22-sorting-algorithms---bubble-sort/</guid>
      <description>&lt;p&gt;In this series of blogs, we will talk about different sorting algorithms.&lt;/p&gt;&#xA;&lt;p&gt;All the algorithms in the table below will be covered.&lt;/p&gt;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;Algorithm&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Average Case)&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Worst Case)&lt;/th&gt;&#xA;&lt;th&gt;Time Complexity (Best Case)&lt;/th&gt;&#xA;&lt;th&gt;Merg&lt;/th&gt;&#xA;&lt;th&gt;Stability&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Bubble Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Quick Sort&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(logN)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Quick Sort (with Random Selection)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(logN)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Insertion Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Selection Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Heap Sort&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(1)&lt;/td&gt;&#xA;&lt;td&gt;Not Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Merge Sort (with double divides)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Merge Sort (with multi divides)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(NlogN)&lt;/td&gt;&#xA;&lt;td&gt;O(N)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Counting Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Bucket Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N^2)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Radix Sort&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N*M)&lt;/td&gt;&#xA;&lt;td&gt;O(N+M)&lt;/td&gt;&#xA;&lt;td&gt;Stable&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;bubble-sort&#34;&gt;Bubble Sort&lt;/h1&gt;&#xA;&lt;h2 id=&#34;how-to-do-it&#34;&gt;How to do it&amp;hellip;&lt;/h2&gt;&#xA;&lt;p&gt;Compare the adjacent elements.&lt;/p&gt;&#xA;&lt;p&gt;If the first element is greater than the second element, swap them.&lt;/p&gt;&#xA;&lt;p&gt;Loop until reaching the last pair of elements.&lt;/p&gt;&#xA;&lt;p&gt;Repeat until all the array is sorted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sorting Algorithms - Summary</title>
      <link>https://junyubian.github.io/posts/2020-04-21-sorting-algorithms---summary/</link>
      <pubDate>Tue, 21 Apr 2020 22:18:10 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-21-sorting-algorithms---summary/</guid>
      <description>&lt;p&gt;In this series of blogs, we will talk about different sorting algorithms.&lt;/p&gt;&#xA;&lt;p&gt;All the algorithms in the table below will be covered.&lt;/p&gt;</description>
    </item>
    <item>
      <title>KMP Algorithm</title>
      <link>https://junyubian.github.io/posts/2020-04-17-kmp-algorithm/</link>
      <pubDate>Fri, 17 Apr 2020 00:31:29 +0000</pubDate>
      <guid>https://junyubian.github.io/posts/2020-04-17-kmp-algorithm/</guid>
      <description>&lt;h1 id=&#34;background&#34;&gt;Background&amp;hellip;&lt;/h1&gt;&#xA;&lt;p&gt;Once upon a time, Tom asked his father to find &lt;code&gt;abab&lt;/code&gt; inside &lt;code&gt;abcaabababaa&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Tom&amp;rsquo;s dad did this in a traditional way (brute force). He compared each character of the first string with each character of the second string. When he find one character not matching, for example, the third character in the second string in this case, he start again from the second character of the second string. It went on and on and on&amp;hellip;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
