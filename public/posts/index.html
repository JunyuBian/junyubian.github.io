<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/all.min.css">
    <link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/my_style.css">
    
    
    
    <title>Junyu Bian | Digital Garden</title>
    <meta name="description" content="">
</head><body><nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
        <a class="navbar-brand" href="https://junyubian.github.io/">
            
            <b style="font-weight: 800;">JB</b>
            
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
            <ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class='nav-item '>
                    <a class="nav-link" href="/garden/"> Digital Garden</a>
                </li>
            <li class='nav-item '>
                    <a class="nav-link" href="/projects/"> Projects</a>
                </li>
            <li class='nav-item '>
                    <a class="nav-link" href="/library/"> Library</a>
                </li>
            <li class='nav-item '>
                    <a class="nav-link" href="/about/"> About</a>
                </li>
             
            <li class="nav-item px-2 pt-1">
                <a class="btn fas fa-moon" id="dark-mode-toggle"></a>
            </li>
            </ul>
        </div>
    </div>
</nav><div id="content">

<div class="container">
    <div class="py-5 rounded-3">
        <div class="container-fluid py-2">
            <h1 class="display-2 mb-4">Digital Garden</h1>
            <p class="bio col-md-8 fs-4 serif">A collection of thoughts and articles at different development stages</p>
        </div>
    </div>
</div>

<div class="container">
    
    <p>
        <h3><a class="title" href="/posts/2023-12-02-hello-world/">Hello World</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2023-12-02">Dec 2, 2023</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/default">default</a>


        <a class="summary" href="/posts/2023-12-02-hello-world/">
            <p>Hello World! Hello World! This is a test file.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2022-10-21-dev-null-related/">/dev/null and 2&amp;&gt;1</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2022-10-21">Oct 21, 2022</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/bash">Bash</a>


        <a class="summary" href="/posts/2022-10-21-dev-null-related/">
            <p>1. Notice 1.1 /dev/null is the null file. Anything written to it is discarded. 1.2 2&gt; means &ldquo;redirect standard-error&rdquo; to the given file. 1.3 2&gt;/dev/null means &ldquo;throw away any error messages&rdquo;. 1.4 1 is stdout. 2 is stderr. 1.5 2&gt;&amp;1 means redirecting stderr to stdout.
2. Example(s) wget -O /dev/null baidu.com 2&gt;&amp;1 3. Reference(s) Sepehr SaminiSepehr Samini 95544 gold badges1111 silver badges1515 bronze badges, et al. “What Does &ldquo;/Dev/Null’ Mean at the End of Shell Commands.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2022-10-21-getopts-in-bash/">getopts in Bash</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2022-10-21">Oct 21, 2022</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/bash">Bash</a>


        <a class="summary" href="/posts/2022-10-21-getopts-in-bash/">
            <p><h1 id="1-notice">1. Notice</h1>
<p>1.1 <code>getopts</code> is different from <code>getopt</code>.
1.2 <code>getopts</code> runs on any system running bash in POSIX mode (e.g., set -o posix), <code>getopt</code> is a system tool varies in different systems.
1.3 <code>getopts</code> parses short options, which are a single dash (&quot;-&quot;) and a letter or digit.e.g. -2, -d, and -D. It can also parse short options in combination, for instance -2dD. But each option will be treated seperately, i.e. -2dD = -2 -d -D not equal -&ldquo;2dD&rdquo;, will need <code>getopt</code> to cope with -&ldquo;2dD&rdquo;.</p></p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-15-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-recursion&#43;backtrack/">LeetCode题目总结-Recursion&#43;Backtrack</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-15">Sep 15, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-15-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-recursion&#43;backtrack/">
            <p>题目17:电话号码的字母组合 描述：
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。
示例:
输入：&ldquo;23&rdquo; 输出：[&ldquo;ad&rdquo;, &ldquo;ae&rdquo;, &ldquo;af&rdquo;, &ldquo;bd&rdquo;, &ldquo;be&rdquo;, &ldquo;bf&rdquo;, &ldquo;cd&rdquo;, &ldquo;ce&rdquo;, &ldquo;cf&rdquo;].
思路：
突破点：回溯。
步骤：
维护一个字符串，表示已有的字母排列； 每次取一个数字，从哈希表中获取可能字母； 将一个字母插入到已有排列后面； 处理下一个数字，直到得到完整排列。 代码：
class Solution { public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; combinations; if (digits.empty()) { return combinations; } unordered_map&lt;char, string&gt; phoneMap{ {&#39;2&#39;, &#34;abc&#34;}, {&#39;3&#39;, &#34;def&#34;}, {&#39;4&#39;, &#34;ghi&#34;}, {&#39;5&#39;, &#34;jkl&#34;}, {&#39;6&#39;, &#34;mno&#34;}, {&#39;7&#39;, &#34;pqrs&#34;}, {&#39;8&#39;, &#34;tuv&#34;}, {&#39;9&#39;, &#34;wxyz&#34;} }; string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations; } void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) { if (index == digits.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-queue&#43;topologicalsort/">LeetCode题目总结-Queue&#43;TopologicalSort</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-12">Sep 12, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-queue&#43;topologicalsort/">
            <p>题目621:任务调度器 描述：
给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。
示例 ：
输入：tasks = [&ldquo;A&rdquo;,&ldquo;A&rdquo;,&ldquo;A&rdquo;,&ldquo;B&rdquo;,&ldquo;B&rdquo;,&ldquo;B&rdquo;], n = 2 输出：8 解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
提示：
任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。
思路：
突破点：桶思想。
步骤：
建立大小为n+1的桶，个数为数量最多的任务； 每个桶视为一轮任务； 总排队时间=(桶个数-1)*(n+1)+最后一个桶的任务数； 代码：
int leastInterval(vector&lt;char&gt;&amp; tasks, int n) { int len=tasks.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-graph/">LeetCode题目总结-Graph</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-12">Sep 12, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-12-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-graph/">
            <p>题目133:克隆图 描述：
给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
class Node { public int val; public List neighbors; }
测试用例格式：
简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。
邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。
给定节点将始终是图中的第一个节点（值为 1）。你必须将给定节点的拷贝作为对克隆图的引用返回。
示例 1：
输入：adjList = [[2,4],[1,3],[2,4],[1,3]] 输出：[[2,4],[1,3],[2,4],[1,3]] 解释： 图中有 4 个节点。 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2：</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-11-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dp&#43;greedy/">LeetCode题目总结-DP&#43;Greedy</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-11">Sep 11, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-11-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dp&#43;greedy/">
            <p>题目5:最长回文子串 描述：
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &ldquo;babad&rdquo; 输出: &ldquo;bab&rdquo; 注意: &ldquo;aba&rdquo; 也是一个有效答案。
示例 2：
输入: &ldquo;cbbd&rdquo; 输出: &ldquo;bb&rdquo;
思路一：（时间超限）
突破点：反转字符串的公共子串。
步骤：
将输入的字符串反转； 求两者的公共子串； 判断该子串是否为所需的最长回文子串。 代码：
class Solution { public: string longestPalindrome(string s) { //大小为1的字符串必为回文串 if(s.length() == 1) return s; string rev = s; string res; std::reverse(rev.begin(),rev.end()); if(rev == s) return s; //存放回文子串的长度 int len = 0; //查找s与rev的最长公共子串 for(int i=0; i&lt;s.length(); i++) { //存放待验证子串 string temp; for(int j=i; j&lt;s.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-09-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-heap&#43;stack/">LeetCode题目总结-Heap&#43;Stack</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-09">Sep 9, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-09-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-heap&#43;stack/">
            <p>题目20:有效的括号 描述：
给定一个只包括 &lsquo;(&rsquo;，&rsquo;)&rsquo;，&rsquo;{&rsquo;，&rsquo;}&rsquo;，&rsquo;[&rsquo;，&rsquo;]&rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
示例 1:
输入: &ldquo;()&rdquo; 输出: true 示例 2:
输入: &ldquo;()[]{}&rdquo; 输出: true 示例 3:
输入: &ldquo;(]&rdquo; 输出: false 示例 4:
输入: &ldquo;([)]&rdquo; 输出: false 示例 5:
输入: &ldquo;{[]}&rdquo; 输出: true
思路：
突破点：使用栈模拟删除过程。
步骤：
使用栈进行存储； 当匹配到最小的括号对时，将这一对从栈中删除； 如果最后栈为空，则为有效。 代码：
class Solution { public: bool isValid(string s) { unordered_map&lt;char,int&gt; m{{&#39;(&#39;,1},{&#39;[&#39;,2},{&#39;{&#39;,3}, {&#39;)&#39;,4},{&#39;]&#39;,5},{&#39;}&#39;,6}}; stack&lt;char&gt; st; bool isTrue = true; for(char c:s){ int flag = m[c]; if(flag&gt;=1 &amp;&amp; flag&lt;=3) { st.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-08-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dfs&#43;bfs/">LeetCode题目总结-DFS&#43;BFS</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-08">Sep 8, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-08-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-dfs&#43;bfs/">
            <p>题目116:填充每个节点的下一个右侧节点指针 描述：
给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node { int val; Node *left; Node *right; Node *next; }
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
示例：
输入：{&quot;$id&quot;:&ldquo;1&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;2&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;3&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:4},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;4&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:5},&ldquo;val&rdquo;:2},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;5&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;6&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:6},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;7&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:7},&ldquo;val&rdquo;:3},&ldquo;val&rdquo;:1}
输出：{&quot;$id&quot;:&ldquo;1&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;2&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;3&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;4&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;5&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;6&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:7},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:6},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:5},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:4},&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;7&rdquo;,&ldquo;left&rdquo;:{&quot;$ref&quot;:&ldquo;5&rdquo;},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;6&rdquo;},&ldquo;val&rdquo;:3},&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;4&rdquo;},&ldquo;val&rdquo;:2},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;7&rdquo;},&ldquo;val&rdquo;:1}
提示：
你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
思路：
突破点：广度优先搜索。
步骤：
使用队列进行广度优先遍历； 在接点出队列后，next指向队列首个元素，广度遍历完直接return。 代码：
class Solution { public: Node* connect(Node* root) { if(!root) return root; queue&lt;Node*&gt; work; work.push(root); work.push(nullptr); Node* cur = nullptr; while(1) { // 如果队列首部是结点 if(work.front()) { cur = work.front(); work.pop(); // 如果是非叶子结点 if(cur-&gt;left) { work.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-two-pointer&#43;linked-list/">LeetCode题目总结-Two Pointer&#43;Linked List</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-06">Sep 6, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-two-pointer&#43;linked-list/">
            <p>题目3:无重复字符的最长子串 描述：
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: &ldquo;abcabcbb&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;abc&rdquo;，所以其长度为 3。
示例 2:
输入: &ldquo;bbbbb&rdquo; 输出: 1 解释: 因为无重复字符的最长子串是 &ldquo;b&rdquo;，所以其长度为 1。 示例 3:
输入: &ldquo;pwwkew&rdquo; 输出: 3 解释: 因为无重复字符的最长子串是 &ldquo;wke&rdquo;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&ldquo;pwke&rdquo; 是一个子序列，不是子串。
思路一：
突破点：滑动窗口。
步骤：
设立指针a和指针b； b指针向右伸缩，对于每个A[b]判断是否之前出现过； 若出现，则a指向出现过的未知的下一位置，更新右指针和最大长度。 代码：
class Solution { public: int lengthOfLongestSubstring(string s) { //s[start,end) 前面包含 后面不包含 int start(0), end(0), length(0), result(0); int stringSize = int(s.size()); while (end &lt; stringSize) { char tmpChar = s[end]; for (int index = start; index &lt; end; index++) { if (tmpChar == s[index]) { start = index + 1; length = end - start; break; } } end++; length++; result = max(result, length); } return result; } }; 思路二：</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-array/">LeetCode题目总结-Array</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-06">Sep 6, 2020</time>

<i data-feather="tag"></i>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/c&#43;&#43;">C&#43;&#43;</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>


<a class="btn btn-sm btn-outline-dark tag-btn" href="https://junyubian.github.io/tags/ch">ch</a>


        <a class="summary" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-array/">
            <p>题目31:下一个排列 描述：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须原地修改，只允许使用额外常数空间。
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1
思路：
突破点：下一个更大排列的特性是什么。
步骤（以[5,6,11,9,7,5,3,1]举例）：
从尾部查找，直到找到当前元素大于前一元素，记录所在位置； 例：[5,6,11,9,7,5,3,1]，找到11大于6，记录位置2；
从1.中的位置到数组尾部的子序列中，找到一个比前一位置的大且相差最小的数； 例：[5,6,11,9,7,5,3,1]，在[11,9,7,5,3,1]找到7，7是比6大且最接近6的，从尾部开始遍历，遍历到大于6的索引即可；
交换2.中找到的数以及1.中确定的前一位置的数； 例：[5,6,11,9,7,5,3,1]，交换后变为[5,7,11,9,6,5,3,1]；
将该位置到数组尾部的子序列进行升序排列，因为已经为降序（1.中确定的位置为首次部位降序的位置），所以首尾两两交换即可； 例：[5,7,11,9,6,5,3,1],交换后为[5,7,1,3,5,6,9,11]；
另外，对于最大的排列，从小到大排列即可。 代码：
// 步骤2函数 int findMin(vector&lt;int&gt; nums, int i) { int pivotEle = nums[i-1]; for (i = nums.size() - 1; i &gt; -1; i--) { if (nums[i] &gt; pivotEle) { break; } } return i; } // 步骤4函数，也可以用 reverse(nums.begin()+i, nums.end());实现 void swap(vector&lt;int&gt; &amp;nums, int i) { int end = nums.</p>
        </a>
    </p>
    
    <p>
        <h3><a class="title" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">LeetCode题目总结</a></h3>
        

<i data-feather="calendar"></i>
<time datetime="2020-09-06">Sep 6, 2020</time>

        <a class="summary" href="/posts/2020-09-06-leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">
            <p></p>
        </a>
    </p>
    
</div>


        </div><div class="container">
    <div class="row justify-content-between">
        <div class="col-sm-4">
            <p class="footer">Junyu Bian© 2023 </p>
        </div>
        <div class="col-sm-6 d-flex flex-row-reverse">
            
            <a class="footer-social px-2"  href="https://twitter.com/junyu_bian" target="_blank"><i class="fab fa-twitter"></i></a>
            
            <a class="footer-social px-2"  href="https://github.com/junyubian" target="_blank"><i class="fab fa-github"></i></a>
            
            <a class="footer-social px-2"  href="https://www.facebook.com/profile.php?id=100010301021817" target="_blank"><i class="fab fa-facebook"></i></a>
            
        </div>
    </div>
</div>
<script src="/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/js/jquery.min.js"></script>
<script src="/js/isotope.pkgd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha384-GNFwBvfVxBkLMJpYMOABq3c+d3KnQxudP/mGPkzpZSTYykLBNsZEnG2D9G/X/+7D" crossorigin="anonymous" async></script>
<script src="/js/dark.js"></script>
<script>


var savedTheme = localStorage.getItem("dark-mode-storage") || "light" 
setTheme(savedTheme);

</script>
<script src="/js/isotope.js"></script>
<script src="/js/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true, securityLevel: 'loose'});</script>
</body>
</html>
