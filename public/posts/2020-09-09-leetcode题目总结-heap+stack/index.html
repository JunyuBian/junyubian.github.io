<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>LeetCode题目总结-Heap&#43;Stack</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	================<br>
	== <a href="https://junyubian.github.io/">Junyu Bian</a> ==<br>
	================
	<div style="float: right;">&#34;Salvation lies within.&#34;</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>LeetCode题目总结-Heap&#43;Stack</h1>
			<b><time>09/09/2020 12:32</time></b>
		       
		           <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
        	       
		           <a href="/tags/%E7%AE%97%E6%B3%95">算法</a>
        	       

			<div>
				<h3 id="题目20有效的括号httpsleetcode-cncomproblemsvalid-parentheses">题目20:<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3>
<hr>
<p>描述：</p>
<p>给定一个只包括 &lsquo;(&rsquo;，&rsquo;)&rsquo;，&rsquo;{&rsquo;，&rsquo;}&rsquo;，&rsquo;[&rsquo;，&rsquo;]&rsquo; 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: &ldquo;()&rdquo;
输出: true
示例 2:</p>
<p>输入: &ldquo;()[]{}&rdquo;
输出: true
示例 3:</p>
<p>输入: &ldquo;(]&rdquo;
输出: false
示例 4:</p>
<p>输入: &ldquo;([)]&rdquo;
输出: false
示例 5:</p>
<p>输入: &ldquo;{[]}&rdquo;
输出: true</p>
<p><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/">思路</a>：</p>
<p>突破点：<code>使用栈模拟删除过程。</code></p>
<p>步骤：</p>
<ol>
<li>使用栈进行存储；</li>
<li>当匹配到最小的括号对时，将这一对从栈中删除；</li>
<li>如果最后栈为空，则为有效。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isValid(string s) {
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m{{<span style="color:#e6db74">&#39;(&#39;</span>,<span style="color:#ae81ff">1</span>},{<span style="color:#e6db74">&#39;[&#39;</span>,<span style="color:#ae81ff">2</span>},{<span style="color:#e6db74">&#39;{&#39;</span>,<span style="color:#ae81ff">3</span>},
</span></span><span style="display:flex;"><span>                                {<span style="color:#e6db74">&#39;)&#39;</span>,<span style="color:#ae81ff">4</span>},{<span style="color:#e6db74">&#39;]&#39;</span>,<span style="color:#ae81ff">5</span>},{<span style="color:#e6db74">&#39;}&#39;</span>,<span style="color:#ae81ff">6</span>}};
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> isTrue <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">char</span> c:s){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> m[c];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(flag<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> flag<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>              st.push(c);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(<span style="color:#f92672">!</span>st.empty() <span style="color:#f92672">&amp;&amp;</span> m[st.top()]<span style="color:#f92672">==</span>flag<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>              st.pop();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              isTrue <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>          isTrue <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> isTrue;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目42接雨水httpsleetcode-cncomproblemstrapping-rain-water">题目42:<a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></h3>
<hr>
<p>描述：</p>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例:</p>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6</p>
<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/">思路一</a>：</p>
<p>突破点：<code>使用栈进行遍历。</code></p>
<p>步骤：</p>
<ol>
<li>使用栈来跟踪可能储水的最长条形块；</li>
<li>如果当前条形块小于或等于栈顶条形块，则将条形块入栈；</li>
<li>如果当前条形块大于栈顶条形块，则暗处栈顶元素，并累加到结果中。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">trap</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, current <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (current <span style="color:#f92672">&lt;</span> height.size()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty() <span style="color:#f92672">&amp;&amp;</span> height[current] <span style="color:#f92672">&gt;</span> height[st.top()]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            st.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (st.empty())
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> distance <span style="color:#f92672">=</span> current <span style="color:#f92672">-</span> st.top() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> bounded_height <span style="color:#f92672">=</span> min(height[current], height[st.top()]) <span style="color:#f92672">-</span> height[top];
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> distance <span style="color:#f92672">*</span> bounded_height;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        st.push(current<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/">思路二</a>：</p>
<p>突破点：<code>使用双指针。</code></p>
<p>步骤：</p>
<ol>
<li>使用双指针；</li>
<li>分别从左和右，更新left_max和right_max；</li>
<li>当发现有小值出现，则累加差值到结果中。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">trap</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> height) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> height.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (left <span style="color:#f92672">&lt;</span> right) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (height[left] <span style="color:#f92672">&lt;</span> height[right]) {
</span></span><span style="display:flex;"><span>            height[left] <span style="color:#f92672">&gt;=</span> left_max <span style="color:#f92672">?</span> (left_max <span style="color:#f92672">=</span> height[left]) <span style="color:#f92672">:</span> ans <span style="color:#f92672">+=</span> (left_max <span style="color:#f92672">-</span> height[left]);
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>left;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            height[right] <span style="color:#f92672">&gt;=</span> right_max <span style="color:#f92672">?</span> (right_max <span style="color:#f92672">=</span> height[right]) <span style="color:#f92672">:</span> ans <span style="color:#f92672">+=</span> (right_max <span style="color:#f92672">-</span> height[right]);
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">--</span>right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="题目71简化路径httpsleetcode-cncomproblemssimplify-path">题目71:<a href="https://leetcode-cn.com/problems/simplify-path/">简化路径</a></h3>
<hr>
<p>描述：</p>
<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p>示例 1：</p>
<p>输入：&quot;/home/&quot;
输出：&quot;/home&quot;
解释：注意，最后一个目录名后面没有斜杠。
示例 2：</p>
<p>输入：&quot;/../&quot;
输出：&quot;/&quot;
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
示例 3：</p>
<p>输入：&quot;/home//foo/&quot;
输出：&quot;/home/foo&quot;
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
示例 4：</p>
<p>输入：&quot;/a/./b/../../c/&quot;
输出：&quot;/c&quot;
示例 5：</p>
<p>输入：&quot;/a/../../b/../c//.//&quot;
输出：&quot;/c&quot;
示例 6：</p>
<p>输入：&quot;/a//b////c/d//././/..&quot;
输出：&quot;/a/b/c&quot;</p>
<p><a href="https://leetcode-cn.com/problems/simplify-path/solution/c-zhan-xian-li-jie-ti-mu-ba-by-zuo-10/">思路一</a>：</p>
<p>突破点：<code>栈。</code></p>
<p>步骤：</p>
<ol>
<li>需要处理三种情况：
<ol>
<li>保证路径以<code>/</code>进行分割；</li>
<li>遇到<code>..</code>，切换为上一级目录；</li>
<li>路径末尾没有<code>/</code>；</li>
</ol>
</li>
<li>使用栈进行存储和遍历处理。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string simplifyPath(string path) {
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;/&#34;</span>;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>        string dir;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : path) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 以 / 为分隔符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 切换上一集目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (dir <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;..&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>                    st.pop();
</span></span><span style="display:flex;"><span>                } 
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 上一个 &#39;/&#39; 到 下一个 &#39;/&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (dir <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;..&#34;</span> <span style="color:#f92672">&amp;&amp;</span> dir <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>dir.empty()) {
</span></span><span style="display:flex;"><span>                    st.push(dir);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                dir.clear();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                dir <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        string result;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>st.empty()) {
</span></span><span style="display:flex;"><span>            string s <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>            st.pop();
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">+</span> s <span style="color:#f92672">+</span> result;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(result.empty()) result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/simplify-path/solution/yong-you-xian-zhuang-tai-ji-de-si-xiang-lai-jie-zh/">思路二</a>：</p>
<p>突破点：<code>状态机。</code></p>
<p>步骤：</p>
<ol>
<li>分为四种状态：
<ol>
<li>前面是一个正常的字符
<ul>
<li>遇到<code>/</code>，则插入结果字符串中，并转至状态2；</li>
<li>遇到<code>.</code>，则转到状态2；</li>
<li>遇到一个正常字符，则插入结果字符串；</li>
</ul>
</li>
<li>前面是一个<code>/</code>
<ul>
<li>遇到<code>/</code>，直接跳过；</li>
<li>遇到<code>.</code>，转到状态3；</li>
<li>遇到一个正常字符，则插入结果字符串，并转到状态1；</li>
</ul>
</li>
<li>前面是一个<code>.</code>
<ul>
<li>遇到<code>/</code>，转到状态2；</li>
<li>遇到<code>.</code>，转到状态4；</li>
<li>遇到一个正常字符，插入<code>.</code>和这个字符，并转到状态1；</li>
</ul>
</li>
<li>前面是<code>..</code>
<ul>
<li>遇到<code>/</code>，则回溯删除到前面一个<code>/</code>；</li>
<li>其余情况则插入一个<code>..</code>和当前字符，并转到状态1。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string simplifyPath(string path) {
</span></span><span style="display:flex;"><span>        string res;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// some flag to kepp state.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 0: last char is [char]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 1: last char is &#39;/&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 2: last char is &#39;.&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#75715e">// 3: last char is &#34;..&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (path.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> path[path.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;/&#39;</span>) path.push_back(<span style="color:#e6db74">&#39;/&#39;</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> path.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> path[i];
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) { res.push_back(<span style="color:#e6db74">&#39;/&#39;</span>); state <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>) state <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> res.push_back(c);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (state <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) {}
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>) { state <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    res.push_back(c); state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (state <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) state <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// &#39;..&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    state <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    res.push_back(<span style="color:#e6db74">&#39;.&#39;</span>); res.push_back(c); state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (state <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// go back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    res.pop_back(); <span style="color:#75715e">// pop &#39;/&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">while</span>(res.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>res.rbegin() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;/&#39;</span>) {
</span></span><span style="display:flex;"><span>                        res.pop_back(); <span style="color:#75715e">// pop anthing until &#39;/&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (res.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) res.push_back(<span style="color:#e6db74">&#39;/&#39;</span>);
</span></span><span style="display:flex;"><span>                    state <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    res.push_back(<span style="color:#e6db74">&#39;.&#39;</span>); 
</span></span><span style="display:flex;"><span>                    res.push_back(<span style="color:#e6db74">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>                    res.push_back(c);
</span></span><span style="display:flex;"><span>                    state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cout &lt;&lt; state &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; &#34; &#34; &lt;&lt; res &lt;&lt;  endl;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((state <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> res.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)) res.pop_back();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目225-用队列实现栈httpsleetcode-cncomproblemsimplement-stack-using-queues">题目225:<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/"> 用队列实现栈</a></h3>
<hr>
<p>描述：</p>
<p>使用队列实现栈的下列操作：</p>
<p>push(x) &ndash; 元素 x 入栈
pop() &ndash; 移除栈顶元素
top() &ndash; 获取栈顶元素
empty() &ndash; 返回栈是否为空
注意:</p>
<p>你只能使用队列的基本操作&ndash; 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-c-dan-dui-lie-ru-zhan-o/">思路一</a>：</p>
<p>突破点：<code>单队列。</code></p>
<p>步骤：</p>
<ol>
<li>维护队列使队头对应栈顶，队尾对应栈底；</li>
<li>在每次在队尾加入元素后，将原本的队列中的元素从头部取出，放入队尾，保证1的性质。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyStack</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Initialize your data structure here. */</span>
</span></span><span style="display:flex;"><span>    MyStack() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Push element x onto stack. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        que.push(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> que.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            que.push(que.front());
</span></span><span style="display:flex;"><span>            que.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Removes the element on top of the stack and returns that element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> top();
</span></span><span style="display:flex;"><span>        que.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> val;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Get the top element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que.front();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Returns whether the stack is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> que;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/225-yong-dui-lie-shi-xian-zhan-liang-ge-dui-lie-sh/">思路二</a>：</p>
<p>突破点：<code>双队列。</code></p>
<p>步骤：</p>
<ol>
<li>创建第二个辅助队列；</li>
<li>第一个队列为主要的取值队列，第二个队列在pop操作时，作为拷贝辅助。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyStack</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> que1;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> que2; <span style="color:#75715e">// 辅助队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/** Initialize your data structure here. */</span>
</span></span><span style="display:flex;"><span>    MyStack() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Push element x onto stack. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        que1.push(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Removes the element on top of the stack and returns that element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> que1.size();
</span></span><span style="display:flex;"><span>        size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 将que1 导入que2，但要留下最后一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (size<span style="color:#f92672">--</span>) { 
</span></span><span style="display:flex;"><span>            que2.push(que1.front());
</span></span><span style="display:flex;"><span>            que1.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 留下的最后一个元素就是我们要返回的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> que1.front(); 
</span></span><span style="display:flex;"><span>        que1.pop();
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 再将que2赋值给que1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        que1 <span style="color:#f92672">=</span> que2; 
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 清空que2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>que2.empty()) { 
</span></span><span style="display:flex;"><span>            que2.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Get the top element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que1.back();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Returns whether the stack is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> que1.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目232用栈实现队列httpsleetcode-cncomproblemsimplement-queue-using-stacks">题目232:<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">用栈实现队列</a></h3>
<hr>
<p>描述：</p>
<p>使用栈实现队列的下列操作：</p>
<p>push(x) &ndash; 将一个元素放入队列的尾部。
pop() &ndash; 从队列首部移除元素。
peek() &ndash; 返回队列首部的元素。
empty() &ndash; 返回队列是否为空。</p>
<p>示例:</p>
<p>MyQueue queue = new MyQueue();</p>
<p>queue.push(1);
queue.push(2);<br>
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false</p>
<p>说明:</p>
<p>你只能使用标准的栈操作 &ndash; 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-liang-ge-zhan-lai-m/">思路</a>：</p>
<p>突破点：<code>两个栈实现队列。</code></p>
<p>步骤：</p>
<ol>
<li>使用两个栈，一个作为输出，一个存储输入值；</li>
<li>当需要pop时，判断输入栈是否为空；</li>
<li>若为空，导入全部输入栈数据并pop；</li>
<li>若不为空，直接pop（因为在peek查看元素之后，会push进输出栈）。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyQueue</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stIn;
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stOut;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Initialize your data structure here. */</span>
</span></span><span style="display:flex;"><span>    MyQueue() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Push element x to the back of queue. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        stIn.push(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Removes the element from in front of queue and returns that element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (stOut.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从stIn导入数据直到stIn为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stIn.empty()) {
</span></span><span style="display:flex;"><span>                stOut.push(stIn.top());
</span></span><span style="display:flex;"><span>                stIn.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> stOut.top();
</span></span><span style="display:flex;"><span>        stOut.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Get the front element. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">peek</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>pop(); <span style="color:#75715e">// 直接使用已有的pop函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        stOut.push(res); <span style="color:#75715e">// 因为pop函数弹出了元素res，所以再添加回去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Returns whether the queue is empty. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stIn.empty() <span style="color:#f92672">&amp;&amp;</span> stOut.empty();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目23合并k个升序链表httpsleetcode-cncomproblemsmerge-k-sorted-lists">题目23:<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h3>
<hr>
<p>描述：</p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
1-&gt;4-&gt;5,
1-&gt;3-&gt;4,
2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
示例 2：</p>
<p>输入：lists = []
输出：[]
示例 3：</p>
<p>输入：lists = [[]]
输出：[]</p>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/c-you-xian-dui-lie-liang-liang-he-bing-fen-zhi-he-/">思路一</a>：</p>
<p>突破点：<code>优先队列。</code></p>
<p>步骤：</p>
<ol>
<li>建立优先队列，使得每个链表头部元素入队；</li>
<li>弹出后，将链表下一个元素入队。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 小根堆的回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmp</span>{  
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(ListNode <span style="color:#f92672">*</span>a,ListNode <span style="color:#f92672">*</span>b){
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> a<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> b<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeKLists</span>(vector<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;&amp;</span> lists) {
</span></span><span style="display:flex;"><span>        priority_queue<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*</span>, vector<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;</span>, cmp<span style="color:#f92672">&gt;</span> pri_queue;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 建立大小为k的小根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> elem : lists){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(elem) pri_queue.push(elem);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 可以使用哑节点/哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ListNode dummy(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>dummy;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 开始出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>pri_queue.empty()){
</span></span><span style="display:flex;"><span>            ListNode<span style="color:#f92672">*</span> top <span style="color:#f92672">=</span> pri_queue.top(); pri_queue.pop();
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> top; p <span style="color:#f92672">=</span> top;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(top<span style="color:#f92672">-&gt;</span>next) pri_queue.push(top<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dummy.next;  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/c-you-xian-dui-lie-liang-liang-he-bing-fen-zhi-he-/">思路二</a>：</p>
<p>突破点：<code>两两合并。</code></p>
<p>步骤：</p>
<ol>
<li>从头开始，两两合并链表。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 合并两个有序链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ListNode<span style="color:#f92672">*</span> merge(ListNode<span style="color:#f92672">*</span> p1, ListNode<span style="color:#f92672">*</span> p2){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p1) <span style="color:#66d9ef">return</span> p2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p2) <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;=</span> p2<span style="color:#f92672">-&gt;</span>val){
</span></span><span style="display:flex;"><span>            p1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> merge(p1<span style="color:#f92672">-&gt;</span>next, p2);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            p2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> merge(p1, p2<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeKLists</span>(vector<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;&amp;</span> lists) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lists.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> lists[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>lists.size(); <span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(lists[i]) head <span style="color:#f92672">=</span> merge(head, lists[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head;  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/c-you-xian-dui-lie-liang-liang-he-bing-fen-zhi-he-/">思路三</a>：</p>
<p>突破点：<code>分治合并。</code></p>
<p>步骤：</p>
<ol>
<li>从头开始，两两分治合并链表；</li>
<li>最后合并剩余的两个链表。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 合并两个有序链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ListNode<span style="color:#f92672">*</span> merge(ListNode<span style="color:#f92672">*</span> p1, ListNode<span style="color:#f92672">*</span> p2){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p1) <span style="color:#66d9ef">return</span> p2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p2) <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;=</span> p2<span style="color:#f92672">-&gt;</span>val){
</span></span><span style="display:flex;"><span>            p1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> merge(p1<span style="color:#f92672">-&gt;</span>next, p2);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p1;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            p2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> merge(p1, p2<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">merge</span>(vector<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;&amp;</span> lists, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(start <span style="color:#f92672">==</span> end) <span style="color:#66d9ef">return</span> lists[start];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (start <span style="color:#f92672">+</span> end) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> l1 <span style="color:#f92672">=</span> merge(lists, start, mid);
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#f92672">*</span> l2 <span style="color:#f92672">=</span> merge(lists, mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> merge(l1, l2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeKLists</span>(vector<span style="color:#f92672">&lt;</span>ListNode<span style="color:#f92672">*&gt;&amp;</span> lists) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lists.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> merge(lists, <span style="color:#ae81ff">0</span>, lists.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目215数组中的第k个最大元素httpsleetcode-cncomproblemskth-largest-element-in-an-array">题目215:<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h3>
<hr>
<p>描述：</p>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/215-by-ikaruga/">思路</a>：</p>
<p>突破点：<code>小顶堆。</code></p>
<p>步骤：</p>
<ol>
<li>使用优先队列建立k大小的小顶堆，堆顶即为所求；</li>
<li>每次直接与堆顶元素进行判断，是否加入堆中。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findKthLargest</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> n : nums) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pq.size() <span style="color:#f92672">==</span> k <span style="color:#f92672">&amp;&amp;</span> pq.top() <span style="color:#f92672">&gt;=</span> n) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pq.size() <span style="color:#f92672">==</span> k) {
</span></span><span style="display:flex;"><span>                pq.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pq.push(n);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pq.top();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2023-12-03-hello-world/">Hello World</a></li>
				
				<li><a href="/posts/2023-11-07-fluent-bit-notes/">Fluent Bit Client Notes</a></li>
				
				<li><a href="/posts/2022-10-21-dev-null-and-21/">/dev/null and 2&amp;&gt;1</a></li>
				
				<li><a href="/posts/2022-10-21-getopts-in-bash/">getopts in Bash</a></li>
				
				<li><a href="/posts/2021-06-05-k8s-and-docker-related-notes/">K8s and docker Related Notes</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2023 <a href="https://junyubian.github.io/"><b>Junyu Bian</b></a>.
	<a href="https://github.com/junyubian"><b>Github</b></a>.
	<a href="https://twitter.com/junyu_bian"><b>Twitter(X)</b></a>.
	<a href="https://www.facebook.com/profile.php?id=100010301021817"><b>Facebook</b></a>.
	<a href="mailto:junyu.bian@qq.com"><b>Mail</b></a>.
	</p>
</footer>

</body>
</html>
