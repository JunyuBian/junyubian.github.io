<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>LeetCode题目总结-DFS&#43;BFS</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	================<br>
	== <a href="https://junyubian.github.io/">Junyu Bian</a> ==<br>
	================
	<div style="float: right;">Notes of Junyu.</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>LeetCode题目总结-DFS&#43;BFS</h1>
			<b><time>09/08/2020 14:03</time></b>
		       
		           <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
        	       
		           <a href="/tags/%E7%AE%97%E6%B3%95">算法</a>
        	       

			<div>
				<h3 id="题目116填充每个节点的下一个右侧节点指针httpsleetcode-cncomproblemspopulating-next-right-pointers-in-each-node">题目116:<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h3>
<hr>
<p>描述：</p>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {
int val;
Node *left;
Node *right;
Node *next;
}</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<p>输入：{&quot;$id&quot;:&ldquo;1&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;2&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;3&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:4},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;4&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:5},&ldquo;val&rdquo;:2},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;5&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;6&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:6},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$id&quot;:&ldquo;7&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:7},&ldquo;val&rdquo;:3},&ldquo;val&rdquo;:1}</p>
<p>输出：{&quot;$id&quot;:&ldquo;1&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;2&rdquo;,&ldquo;left&rdquo;:{&quot;$id&quot;:&ldquo;3&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;4&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;5&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;6&rdquo;,&ldquo;left&rdquo;:null,&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:7},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:6},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:5},&ldquo;right&rdquo;:null,&ldquo;val&rdquo;:4},&ldquo;next&rdquo;:{&quot;$id&quot;:&ldquo;7&rdquo;,&ldquo;left&rdquo;:{&quot;$ref&quot;:&ldquo;5&rdquo;},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;6&rdquo;},&ldquo;val&rdquo;:3},&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;4&rdquo;},&ldquo;val&rdquo;:2},&ldquo;next&rdquo;:null,&ldquo;right&rdquo;:{&quot;$ref&quot;:&ldquo;7&rdquo;},&ldquo;val&rdquo;:1}</p>
<p>提示：</p>
<p>你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/dui-lie-mo-ni-yan-du-bian-li-shi-jian-97kong-jian-/">思路</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>使用队列进行广度优先遍历；</li>
<li>在接点出队列后，next指向队列首个元素，广度遍历完直接return。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> connect(Node<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    	queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> work;
</span></span><span style="display:flex;"><span>      work.push(root);
</span></span><span style="display:flex;"><span>    	work.push(<span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    	Node<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果队列首部是结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(work.front()) {
</span></span><span style="display:flex;"><span>        	cur <span style="color:#f92672">=</span> work.front();
</span></span><span style="display:flex;"><span>    			work.pop();
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 如果是非叶子结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>          	work.push(cur<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    				work.push(cur<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>    			cur<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> work.front();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果只剩下一个nullptr结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    		<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> work.size()) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果遇到nullptr结点，这是一层的分割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    			work.pop();
</span></span><span style="display:flex;"><span>    			work.push(<span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    		}
</span></span><span style="display:flex;"><span>    	}
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目117填充每个节点的下一个右侧节点指针-iihttpsleetcode-cncomproblemspopulating-next-right-pointers-in-each-node-ii">题目117:<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></h3>
<hr>
<p>描述：</p>
<p>给定一个二叉树</p>
<p>struct Node {
int val;
Node *left;
Node *right;
Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p>输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]</p>
<p>提示：</p>
<p>树中的节点数小于 6000
-100 &lt;= node.val &lt;= 100</p>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/cceng-ci-bian-li-by-mrnice/">思路</a>：</p>
<p>突破点：<code>层次遍历。</code></p>
<p>步骤：</p>
<ol>
<li>使用队列层次遍历；</li>
<li>每循环一层将这一层清空，录入孩子节点。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> connect(Node<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> q{{root}};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> q.size();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                Node<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> i){
</span></span><span style="display:flex;"><span>                    Node<span style="color:#f92672">*</span> tNext <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>                    t<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> tNext;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(t<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>                  q.push(t<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(t<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>                  q.push(t<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目200岛屿数量httpsleetcode-cncomproblemsnumber-of-islands">题目200:<a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a></h3>
<hr>
<p>描述：</p>
<p>给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<p>输入:
[
[&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;],
[&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;],
[&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;],
[&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;]
]
输出: 1
示例 2:</p>
<p>输入:
[
[&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;],
[&lsquo;1&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;],
[&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;1&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;],
[&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;0&rsquo;,&lsquo;1&rsquo;,&lsquo;1&rsquo;]
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">思路一</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将二维网格视为无向图，相邻1之间有边相连；</li>
<li>搜索到1，则标记为0；</li>
<li>最终深度优先搜索次数即为岛屿数量。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> dfs(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> grid, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nr <span style="color:#f92672">=</span> grid.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nc <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        grid[r][c] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> grid[r<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][c]) dfs(grid, r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, c);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> nr <span style="color:#f92672">&amp;&amp;</span> grid[r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][c]) dfs(grid, r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, c);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> c <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> grid[r][c<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) dfs(grid, r, c <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> nc <span style="color:#f92672">&amp;&amp;</span> grid[r][c<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) dfs(grid, r, c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numIslands(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nr <span style="color:#f92672">=</span> grid.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nr) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nc <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> num_islands <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; r <span style="color:#f92672">&lt;</span> nr; <span style="color:#f92672">++</span>r) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; c <span style="color:#f92672">&lt;</span> nc; <span style="color:#f92672">++</span>c) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> grid[r][c]) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">++</span>num_islands;
</span></span><span style="display:flex;"><span>                    dfs(grid, r, c);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num_islands;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">思路二</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将二维网格视为无向图，相邻1之间有边相连；</li>
<li>搜索到1，则加入队列，并修改标记为0；</li>
<li>最终广度优先搜索次数即为岛屿数量。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numIslands(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nr <span style="color:#f92672">=</span> grid.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nr) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nc <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> num_islands <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; r <span style="color:#f92672">&lt;</span> nr; <span style="color:#f92672">++</span>r) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; c <span style="color:#f92672">&lt;</span> nc; <span style="color:#f92672">++</span>c) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (grid[r][c] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                  <span style="color:#f92672">++</span>num_islands;
</span></span><span style="display:flex;"><span>                  grid[r][c] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                  queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> neighbors;
</span></span><span style="display:flex;"><span>                  neighbors.push({r, c});
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>neighbors.front()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> rc <span style="color:#f92672">=</span> neighbors.front();
</span></span><span style="display:flex;"><span>                    neighbors.pop();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> rc.first, col <span style="color:#f92672">=</span> rc.second;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">==</span> grid[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col]) {
</span></span><span style="display:flex;"><span>                      neighbors.push({row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, col});
</span></span><span style="display:flex;"><span>                      grid[row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][col] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (row <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> nr <span style="color:#f92672">&amp;&amp;</span> grid[row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][col] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                      neighbors.push({row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, col});
</span></span><span style="display:flex;"><span>                      grid[row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][col] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (col <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> grid[row][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                      neighbors.push({row, col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>});
</span></span><span style="display:flex;"><span>                      grid[row][col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> nc <span style="color:#f92672">&amp;&amp;</span> grid[row][col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
</span></span><span style="display:flex;"><span>                      neighbors.push({row, col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>});
</span></span><span style="display:flex;"><span>                      grid[row][col<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                  }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num_islands;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目207课程表httpsleetcode-cncomproblemscourse-schedule">题目207:<a href="https://leetcode-cn.com/problems/course-schedule/">课程表</a></h3>
<hr>
<p>描述：</p>
<p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
示例 2:</p>
<p>输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p>提示：</p>
<p>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。
你可以假定输入的先决条件中没有重复的边。
1 &lt;= numCourses &lt;= 10^5</p>
<p><a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">思路一</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>题目即寻找有向图中是否成环；</li>
<li>通过深度优先搜索，寻找拓扑排序；</li>
<li>如果存在，说明无环，如果不存在，说明有环。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> visited;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> valid <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> dfs(<span style="color:#66d9ef">int</span> u) {
</span></span><span style="display:flex;"><span>        visited[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v: edges[u]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> visited[v]) {
</span></span><span style="display:flex;"><span>                dfs(v);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>valid) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> visited[v]) {
</span></span><span style="display:flex;"><span>                valid <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        visited[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">canFinish</span>(<span style="color:#66d9ef">int</span> numCourses, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> prerequisites) {
</span></span><span style="display:flex;"><span>        edges.resize(numCourses);
</span></span><span style="display:flex;"><span>        visited.resize(numCourses);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> info: prerequisites) {
</span></span><span style="display:flex;"><span>            edges[info[<span style="color:#ae81ff">1</span>]].push_back(info[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numCourses <span style="color:#f92672">&amp;&amp;</span> valid; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[i]) {
</span></span><span style="display:flex;"><span>                dfs(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> valid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">思路二</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>题目即寻找有向图中是否成环；</li>
<li>通过广度优先搜索，寻找拓扑排序；</li>
<li>寻找所有入度为0的点放入队列；</li>
<li>每一步广度优先搜索时，取出队首节点，加入答案中；</li>
<li>移除该点的所有出边；</li>
<li>如果有某个相邻节点入度变为0，则将该节点加入答案；</li>
<li>结束后，如果答案包含n各节点，则找到一种拓扑排序；</li>
<li>否则，说明存在环。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indeg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> canFinish(<span style="color:#66d9ef">int</span> numCourses, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;&amp;</span> prerequisites) {
</span></span><span style="display:flex;"><span>        edges.resize(numCourses);
</span></span><span style="display:flex;"><span>        indeg.resize(numCourses);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> info: prerequisites) {
</span></span><span style="display:flex;"><span>            edges[info[<span style="color:#ae81ff">1</span>]].push_back(info[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>indeg[info[<span style="color:#ae81ff">0</span>]];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numCourses; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> indeg[i]) {
</span></span><span style="display:flex;"><span>                q.push(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> visited <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>visited;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v: edges[u]) {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">--</span>indeg[v];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> indeg[v]) {
</span></span><span style="display:flex;"><span>                    q.push(v);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> visited <span style="color:#f92672">==</span> numCourses;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目210课程表-iihttpsleetcode-cncomproblemscourse-schedule-ii">题目210:<a href="https://leetcode-cn.com/problems/course-schedule-ii/">课程表 II</a></h3>
<hr>
<p>描述：</p>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:</p>
<p>输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
说明:</p>
<p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
你可以假定输入的先决条件中没有重复的边。
提示:</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
拓扑排序也可以通过 BFS 完成。</p>
<p><a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">思路</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>思考过程与题目207类似；</li>
<li>当我们标记当前节点u为”搜索中“后，遍历每个相邻节点v；</li>
<li>如果为未搜索，则开始搜索v，搜索完成后回溯到u；</li>
<li>如果为搜索中，则找到一个环，返回false；</li>
<li>如果为已完成，说明v已经在栈中，不进行操作；</li>
<li>u所有相邻节点都为”已完成“后，将u入栈，并标记为已完成。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 存储有向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> visited;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断有向图中是否有环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> valid <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> dfs(<span style="color:#66d9ef">int</span> u) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将节点标记为「搜索中」
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visited[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 搜索其相邻节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 只要发现有环，立刻停止搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v: edges[u]) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果「未搜索」那么搜索相邻节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (visited[v] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                dfs(v);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>valid) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果「搜索中」说明找到了环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (visited[v] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                valid <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将节点标记为「已完成」
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visited[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将节点入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result.push_back(u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> findOrder(<span style="color:#66d9ef">int</span> numCourses, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> prerequisites) {
</span></span><span style="display:flex;"><span>        edges.resize(numCourses);
</span></span><span style="display:flex;"><span>        visited.resize(numCourses);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> info: prerequisites) {
</span></span><span style="display:flex;"><span>            edges[info[<span style="color:#ae81ff">1</span>]].push_back(info[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numCourses <span style="color:#f92672">&amp;&amp;</span> valid; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[i]) {
</span></span><span style="display:flex;"><span>                dfs(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>valid) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果没有环，那么就有拓扑排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 注意下标 0 为栈底，因此需要将数组反序输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reverse(result.begin(), result.end());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目279完全平方数httpsleetcode-cncomproblemsperfect-squares">题目279:<a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h3>
<hr>
<p>描述：</p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n = 12
输出: 3
解释: 12 = 4 + 4 + 4.
示例 2:</p>
<p>输入: n = 13
输出: 2
解释: 13 = 4 + 9.</p>
<p><a href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfsliang-chong-fang-fa-by-yu-mu-2/">思路一</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将题目抽象为从n走到0，每次跨越平方距离，求最少跨越次数；</li>
<li>使用BFS解决。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*返回小于n的平方序列: 1, 4, 9...*/</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getSquares(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">*</span>i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            res.push_back(i<span style="color:#f92672">*</span>i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numSquares</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> squares <span style="color:#f92672">=</span> getSquares(n);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> visited(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);    <span style="color:#75715e">//记录已访问过的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        q.push(n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        visited[n] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> q.size();
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>          
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(size<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> curr <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/*每次跨越的间隔为平方数*/</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> num: squares) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> next <span style="color:#f92672">=</span> curr <span style="color:#f92672">-</span> num;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">&gt;</span> next) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> next) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    visited[next] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                    q.push(next);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/perfect-squares/solution/yi-ge-wan-quan-bei-bao-wen-ti-by-wtffqbpl/">思路二</a>：</p>
<p>突破点：<code>动态规划。</code></p>
<p>步骤：</p>
<ol>
<li>将题目理解为背包问题；</li>
<li>背包容量v[i]表示每个完全平方数字的大小；</li>
<li>背包价值w[i]为1；</li>
<li>求解组成数组所需要的完全平方数数量最少即为背包的价值最低。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> numSquares(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> choices;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构造物品，即所有小于给定数字的完全平方数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (n <span style="color:#f92672">/</span> res <span style="color:#f92672">&gt;=</span> res) {
</span></span><span style="display:flex;"><span>            choices.push_back(res <span style="color:#f92672">*</span> res);
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> choices.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// init
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            dp[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 完全背包模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> size; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> choices[i]; j <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">=</span> min(dp[j], dp[j <span style="color:#f92672">-</span> choices[i]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目301删除无效的括号httpsleetcode-cncomproblemsremove-invalid-parentheses">题目301:<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">删除无效的括号</a></h3>
<hr>
<p>描述：</p>
<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p>
<p>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p>
<p>示例 1:</p>
<p>输入: &ldquo;()())()&rdquo;
输出: [&quot;()()()&quot;, &ldquo;(())()&rdquo;]
示例 2:</p>
<p>输入: &ldquo;(a)())()&rdquo;
输出: [&quot;(a)()()&quot;, &ldquo;(a())()&rdquo;]
示例 3:</p>
<p>输入: &ldquo;)(&rdquo;
输出: [&quot;&quot;]</p>
<p><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/dfsjie-ti-by-hw_wt/">思路</a>：</p>
<p>突破点：<code>深度优先遍历。</code></p>
<p>步骤：</p>
<ol>
<li>首先遍历输入字符串，获取需要删除的左右括号个数；</li>
<li>递归循环进行左右删除；</li>
<li>当1.中计数都为0时，检查输入字符串是否有效。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isvalid(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>                cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (c <span style="color:#f92672">==</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>)<span style="color:#960050;background-color:#1e0010">&#39;</span>) {
</span></span><span style="display:flex;"><span>                cnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(string s, <span style="color:#66d9ef">int</span> st, <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> ans) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isvalid(s)) {
</span></span><span style="display:flex;"><span>                ans.push_back(s);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> st; i <span style="color:#f92672">&lt;</span> s.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> st <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">==</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">&amp;&amp;</span> l <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 删除操作，substr(a, b):从a开始个字符组成的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dfs(s.substr(<span style="color:#ae81ff">0</span>, i) <span style="color:#f92672">+</span> s.substr(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, s.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i), i, l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, r, ans);
</span></span><span style="display:flex;"><span>            } 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span> <span style="color:#f92672">&amp;&amp;</span> r <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 删除操作，substr(a, b):从a开始个字符组成的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                dfs(s.substr(<span style="color:#ae81ff">0</span>, i) <span style="color:#f92672">+</span> s.substr(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, s.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i), i, l, r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, ans);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> removeInvalidParentheses(string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (c <span style="color:#f92672">==</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>)<span style="color:#960050;background-color:#1e0010">&#39;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) { 
</span></span><span style="display:flex;"><span>                    left<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// left和right表示左右括号要删除的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        dfs(s, <span style="color:#ae81ff">0</span>, left, right, ans);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2023-12-03-hello-world/">Hello World</a></li>
				
				<li><a href="/posts/2023-11-07-fluent-bit-notes/">Fluent Bit Client Notes</a></li>
				
				<li><a href="/posts/2022-10-21-dev-null-and-21/">/dev/null and 2&amp;&gt;1</a></li>
				
				<li><a href="/posts/2022-10-21-getopts-in-bash/">getopts in Bash</a></li>
				
				<li><a href="/posts/2021-06-05-k8s-and-docker-related-notes/">K8s and docker Related Notes</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2023 <a href="https://junyubian.github.io/"><b>Junyu Bian</b></a>.
	<a href="https://github.com/junyubian"><b>Github</b></a>.
	<a href="https://twitter.com/junyu_bian"><b>Twitter(X)</b></a>.
	<a href="https://www.facebook.com/profile.php?id=100010301021817"><b>Facebook</b></a>.
	<a href="mailto:junyu.bian@qq.com"><b>Mail</b></a>.
	</p>
</footer>

</body>
</html>
