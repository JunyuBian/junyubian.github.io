<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>LeetCode题目总结-Tree&#43;BST</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	================<br>
	== <a href="https://junyubian.github.io/">Junyu Bian</a> ==<br>
	================
	<div style="float: right;">Welcome to my posts!</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories/"><b>Categories</b></a>.
			
			<a href="/tags/"><b>Tags</b></a>.
			
			<a href="/about/"><b>About</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>LeetCode题目总结-Tree&#43;BST</h1>
			<b><time>09/07/2020 21:13</time></b>
		       
		           <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
        	       
		           <a href="/tags/%E7%AE%97%E6%B3%95">算法</a>
        	       
		           <a href="/tags/ch">ch</a>
        	       

			<div>
				<h3 id="题目94二叉树的中序遍历httpsleetcode-cncomproblemsbinary-tree-inorder-traversal">题目94:<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h3>
<hr>
<p>描述：</p>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]
1
<br>
2
/
3</p>
<p>输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/che-di-chi-tou-er-cha-shu-de-qian-zhong-hou-xu-di-/">思路一</a>：</p>
<p>突破点：<code>递归。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">traversal</span>(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> cur) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/che-di-chi-tou-er-cha-shu-de-qian-zhong-hou-xu-di-/">思路二</a>：</p>
<p>突破点：<code>迭代。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> inorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> tempStack;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> root) tempStack.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>tempStack.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> tempStack.top();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.pop(); 
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 添加右节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) tempStack.push(node<span style="color:#f92672">-&gt;</span>right); 
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 添加中节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.push(node);
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 中节点访问过，但是还没有处理，需要做一下标记。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.push(<span style="color:#66d9ef">nullptr</span>); 
</span></span><span style="display:flex;"><span>								<span style="color:#75715e">// 添加左节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) tempStack.push(node<span style="color:#f92672">-&gt;</span>left); 
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 将空节点弹出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.pop(); 
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 重新取出栈中元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                node <span style="color:#f92672">=</span> tempStack.top(); 
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 加入到数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                result.push_back(node<span style="color:#f92672">-&gt;</span>val); 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目144二叉树的前序遍历httpsleetcode-cncomproblemsbinary-tree-preorder-traversal">题目144:<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></h3>
<hr>
<p>描述：</p>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>
1
<br>
2
/
3</p>
<p>输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/">思路一</a>：</p>
<p>突破点：<code>递归。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> traversal(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> cur) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        traversal(root, result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/">思路二</a>：</p>
<p>突破点：<code>迭代。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> tempStack;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> root) tempStack.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>tempStack.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> tempStack.top();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) tempStack.push(node<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) tempStack.push(node<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.push(node);                          <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.push(NULL);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                node <span style="color:#f92672">=</span> tempStack.top();
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                result.push_back(node<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目145二叉树的后序遍历httpsleetcode-cncomproblemsbinary-tree-postorder-traversal">题目145:<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></h3>
<hr>
<p>描述：</p>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>
1
<br>
2
/
3</p>
<p>输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>思路一：</p>
<p>突破点：<code>递归。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> traversal(TreeNode<span style="color:#f92672">*</span> cur, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> vec) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> cur) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        traversal(cur<span style="color:#f92672">-&gt;</span>left, vec);  <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        traversal(cur<span style="color:#f92672">-&gt;</span>right, vec); <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec.push_back(cur<span style="color:#f92672">-&gt;</span>val);    <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        traversal(root, result);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/dai-ma-sui-xiang-lu-chi-tou-qian-zhong-hou-xu-de-d/">思路二</a>：</p>
<p>突破点：<code>迭代。</code></p>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> tempStack;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> root) tempStack.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>tempStack.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> tempStack.top();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                tempStack.push(node);                          <span style="color:#75715e">// 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                tempStack.push(NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>right) tempStack.push(node<span style="color:#f92672">-&gt;</span>right);  <span style="color:#75715e">// 右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>left) tempStack.push(node<span style="color:#f92672">-&gt;</span>left);    <span style="color:#75715e">// 左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                node <span style="color:#f92672">=</span> tempStack.top();
</span></span><span style="display:flex;"><span>                tempStack.pop();
</span></span><span style="display:flex;"><span>                result.push_back(node<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目112路径总和httpsleetcode-cncomproblemspath-sum">题目112:<a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></h3>
<hr>
<p>描述：
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre tabindex="0"><code>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</code></pre><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<p><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">思路一</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>使用广度优先搜索，计算从根节点到当前节点的路径和；</li>
<li>使用两个队列，分别存储要遍历的节点和根节点到这些节点的路径和。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> hasPathSum(TreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> sum) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>TreeNode <span style="color:#f92672">*&gt;</span> queNode;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> queVal;
</span></span><span style="display:flex;"><span>        queNode.push(root);
</span></span><span style="display:flex;"><span>        queVal.push(root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>queNode.empty()) {
</span></span><span style="display:flex;"><span>            TreeNode <span style="color:#f92672">*</span>now <span style="color:#f92672">=</span> queNode.front();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> queVal.front();
</span></span><span style="display:flex;"><span>            queNode.pop();
</span></span><span style="display:flex;"><span>            queVal.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span>now<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> now<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (temp <span style="color:#f92672">==</span> sum) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">!=</span> now<span style="color:#f92672">-&gt;</span>left) {
</span></span><span style="display:flex;"><span>                queNode.push(now<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                queVal.push(now<span style="color:#f92672">-&gt;</span>left<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+</span> temp);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (now<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>                queNode.push(now<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>                queVal.push(now<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">+</span> temp);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/">思路二</a>：</p>
<p>突破点：<code>递归。</code></p>
<p>步骤：</p>
<ol>
<li>问题细化，即为求是否存在从当前节点的子节点到叶子节点的路径，使得路径和为sum-val；</li>
<li>若当前节点为叶子节点，则直接判断sum是否与val相等；</li>
<li>若非叶子节点，需递归进行查询。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> hasPathSum(TreeNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> sum) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> sum <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hasPathSum</span>(root<span style="color:#f92672">-&gt;</span>left, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>               hasPathSum(root<span style="color:#f92672">-&gt;</span>right, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目113路径总和-iihttpsleetcode-cncomproblemspath-sum-ii">题目113:<a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和 II</a></h3>
<hr>
<p>描述：
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre tabindex="0"><code>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
</code></pre><p>返回:</p>
<pre tabindex="0"><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre><p><a href="https://leetcode-cn.com/problems/path-sum-ii/solution/di-gui-ji-suan-lu-jing-zong-he-by-jarvis1890/">思路</a>：</p>
<p>突破点：<code>DFS。</code></p>
<p>步骤：</p>
<ol>
<li>递归记录当前路径上所有节点的值；</li>
<li>当递归至叶子节点，计算路径总和并比较。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> sum, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> valVec){
</span></span><span style="display:flex;"><span>        valVec.push_back(root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>right){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> n: valVec) s <span style="color:#f92672">+=</span> n;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(s <span style="color:#f92672">==</span> sum) ans.push_back(valVec);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>left) dfs(root<span style="color:#f92672">-&gt;</span>left, sum, valVec);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>right) dfs(root<span style="color:#f92672">-&gt;</span>right, sum, valVec);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> pathSum(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> sum) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>        dfs(root, sum, {});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h3 id="题目235二叉搜索树的最近公共祖先httpsleetcode-cncomproblemslowest-common-ancestor-of-a-binary-search-tree">题目235:<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h3>
<hr>
<p>描述：</p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/lca-by-ai-mao-de-xiao-gen-ban/">思路</a>：</p>
<p>突破点：<code>递归。</code></p>
<p>步骤：</p>
<ol>
<li>分左右两边进行递归；</li>
<li>如果左边没有找到，说明公共祖先在右边；</li>
<li>如果右边没有找到，说明公共祖先在左边；</li>
<li>如果左右均不为空，则说明找到了。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(TreeNode<span style="color:#f92672">*</span> root, TreeNode<span style="color:#f92672">*</span> p, TreeNode<span style="color:#f92672">*</span> q) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//递归边界返回空或者返回存在的那个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root <span style="color:#f92672">||</span> root <span style="color:#f92672">==</span> p <span style="color:#f92672">||</span> root <span style="color:#f92672">==</span> q) <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//左边找一找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TreeNode<span style="color:#f92672">*</span> leftNode <span style="color:#f92672">=</span> lowestCommonAncestor(root<span style="color:#f92672">-&gt;</span>left,p,q);
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//右边找一找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TreeNode<span style="color:#f92672">*</span> rightNode <span style="color:#f92672">=</span> lowestCommonAncestor(root<span style="color:#f92672">-&gt;</span>right,p,q);
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//返回NULL或者有的那一侧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> leftNode)<span style="color:#66d9ef">return</span> rightNode;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> rightNode)<span style="color:#66d9ef">return</span> leftNode;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//当前祖先左边有p，右边有q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> root;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="题目1382将二叉搜索树变平衡httpsleetcode-cncomproblemsbalance-a-binary-search-tree">题目1382:<a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/">将二叉搜索树变平衡</a></h3>
<hr>
<p>描述：</p>
<p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p>
<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</p>
<p>如果有多种构造方法，请你返回任意一种。</p>
<p>示例：</p>
<p>输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。</p>
<p>提示：</p>
<p>树节点的数目在 1 到 10^4 之间。
树节点的值互不相同，且在 1 到 10^5 之间。</p>
<p><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/di-gui-on-jie-fa-c-you-xian-dui-lie-by-time-limit/">思路</a>：</p>
<p>突破点：<code>DFS。</code></p>
<p>步骤：</p>
<ol>
<li>使用升序数组构造平衡二叉搜索树；</li>
<li>设长度为n，则n/2处元素为根节点；</li>
<li>递归进行构造。</li>
</ol>
<p>代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(TreeNode <span style="color:#f92672">*</span>root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>vec) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root) { 
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span>; 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        dfs(root<span style="color:#f92672">-&gt;</span>left, vec);
</span></span><span style="display:flex;"><span>        vec.push_back(root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        dfs(root<span style="color:#f92672">-&gt;</span>right, vec);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">construct</span>(<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>vec, <span style="color:#66d9ef">int</span> leftVal, <span style="color:#66d9ef">int</span> rightVal) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(leftVal <span style="color:#f92672">&gt;</span> rightVal) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (leftVal<span style="color:#f92672">+</span>rightVal)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(vec[mid]);
</span></span><span style="display:flex;"><span>        ptr<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> construct(vec, mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, rightVal);
</span></span><span style="display:flex;"><span>        ptr<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> construct(vec, leftVal, mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ptr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> balanceBST(TreeNode<span style="color:#f92672">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">nullptr</span> <span style="color:#f92672">==</span> root) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> data;
</span></span><span style="display:flex;"><span>        dfs(root, data);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">construct</span>(data, <span style="color:#ae81ff">0</span>, data.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/2023-12-02-criterions-for-site/">Criterions for Site</a></li>
				
				<li><a href="/posts/2023-12-02-hugo-site-auto-deployment-with-github-action/">Hugo Site Auto Deployment with Github Action</a></li>
				
				<li><a href="/posts/2023-12-02-hello-world/">Hello World</a></li>
				
				<li><a href="/posts/2023-11-07-fluent-bit-notes/">Fluent Bit Client Notes</a></li>
				
				<li><a href="/posts/2022-10-21-dev-null-and-21/">/dev/null and 2&amp;&gt;1</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2023 <a href="https://junyubian.github.io/"><b>Junyu Bian</b></a>.
	<a href="https://github.com/junyubian"><b>Github</b></a>.
	<a href="https://twitter.com/junyu_bian"><b>Twitter(X)</b></a>.
	<a href="https://www.facebook.com/profile.php?id=100010301021817"><b>Facebook</b></a>.
	<a href="mailto:junyu.bian@qq.com"><b>Mail</b></a>.
	</p>
</footer>

</body>
</html>
